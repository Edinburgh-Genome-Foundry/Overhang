{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"EGF's Compendium of overhangs This Python package generates a description of an input set of DNA overhangs and outputs a PDF file. Additionally, it evaluates suitability of an input set of overhangs for Golden Gate DNA assembly. Install # pip install overhang pip install --upgrade git+https://github.com/Edinburgh-Genome-Foundry/overhang.git@main Usage import overhang as oh overhang = oh . Overhang ( \"TCAT\" ) dir ( overhang ) overhang_classes = oh . generate_all_overhangs () oh . write_pdf_report ( target = \"examples/compendium.pdf\" , overhangs = overhang_classes ) See compendium.pdf . Inspect a set of overhangs for assembly: overhangset = oh . OverhangSet ( overhangs = [ \"ATGG\" , \"GAAA\" , \"CACC\" , \"GACT\" , \"ATGG\" , \"CCAG\" ,], name = \"Example\" , ) oh . write_overhangset_report ( \"examples/set_report_Example.pdf\" , overhangset ) # Esp3I Tatapov plot (37 Celsius, 1 hour): The first page of the report : Improve an overhang set by removing the bad interactions: overhangs = [ 'TAGG' , 'ATGG' , 'GACT' , 'GGAC' , 'TCCG' , 'CCAG' , 'CAGC' , 'AGGC' ] overhangset = oh . OverhangSet ( overhangs = overhangs , name = \"Example 2\" ) overhangset . find_perfect_subset () # Overhangs in subset: ['TAGG', 'CCAG', 'AGGC', 'TCCG'] # Number of overhangs in subset: 4 # Esp3I Tatapov plot (37 Celsius, 1 hour): Another approach is to iteratively remove the worst weakly annealing, self-misannealing, and misannealing overhang interactions until the desired number of overhangs is reached. Versioning Overhang uses the semantic versioning scheme. Copyright Copyright 2021 Edinburgh Genome Foundry Overhang was written at the Edinburgh Genome Foundry by Peter Vegh .","title":"Home"},{"location":"#egfs-compendium-of-overhangs","text":"This Python package generates a description of an input set of DNA overhangs and outputs a PDF file. Additionally, it evaluates suitability of an input set of overhangs for Golden Gate DNA assembly.","title":"EGF's Compendium of overhangs"},{"location":"#install","text":"# pip install overhang pip install --upgrade git+https://github.com/Edinburgh-Genome-Foundry/overhang.git@main","title":"Install"},{"location":"#usage","text":"import overhang as oh overhang = oh . Overhang ( \"TCAT\" ) dir ( overhang ) overhang_classes = oh . generate_all_overhangs () oh . write_pdf_report ( target = \"examples/compendium.pdf\" , overhangs = overhang_classes ) See compendium.pdf . Inspect a set of overhangs for assembly: overhangset = oh . OverhangSet ( overhangs = [ \"ATGG\" , \"GAAA\" , \"CACC\" , \"GACT\" , \"ATGG\" , \"CCAG\" ,], name = \"Example\" , ) oh . write_overhangset_report ( \"examples/set_report_Example.pdf\" , overhangset ) # Esp3I Tatapov plot (37 Celsius, 1 hour): The first page of the report : Improve an overhang set by removing the bad interactions: overhangs = [ 'TAGG' , 'ATGG' , 'GACT' , 'GGAC' , 'TCCG' , 'CCAG' , 'CAGC' , 'AGGC' ] overhangset = oh . OverhangSet ( overhangs = overhangs , name = \"Example 2\" ) overhangset . find_perfect_subset () # Overhangs in subset: ['TAGG', 'CCAG', 'AGGC', 'TCCG'] # Number of overhangs in subset: 4 # Esp3I Tatapov plot (37 Celsius, 1 hour): Another approach is to iteratively remove the worst weakly annealing, self-misannealing, and misannealing overhang interactions until the desired number of overhangs is reached.","title":"Usage"},{"location":"#versioning","text":"Overhang uses the semantic versioning scheme.","title":"Versioning"},{"location":"#copyright","text":"Copyright 2021 Edinburgh Genome Foundry Overhang was written at the Edinburgh Genome Foundry by Peter Vegh .","title":"Copyright"},{"location":"reference/overhang/","text":"Module overhang View Source from .Overhang import Overhang , generate_all_overhangs from .OverhangSet import OverhangSet from .tools import ( order_overhangs , generate_overhang_pairs , subset_data_for_overhang , plot_data , filter_overhangs , ) from .reports import write_pdf_report , write_overhangset_report DISASTANDARD = [ \"AATT\" , # palindromic error \"TAGG\" , \"CCTA\" , # reverse complements error \"TCCG\" , \"TCCG\" , # duplicate overhangs error \"CACC\" , # weakest correct warning \"GACT\" , # self-misannealing warning \"ATGG\" , \"CCAG\" , # misannealing pair warning ] Sub-modules overhang.Overhang overhang.OverhangSet overhang.reports overhang.tools overhang.version Variables DISASTANDARD","title":"Index"},{"location":"reference/overhang/#module-overhang","text":"View Source from .Overhang import Overhang , generate_all_overhangs from .OverhangSet import OverhangSet from .tools import ( order_overhangs , generate_overhang_pairs , subset_data_for_overhang , plot_data , filter_overhangs , ) from .reports import write_pdf_report , write_overhangset_report DISASTANDARD = [ \"AATT\" , # palindromic error \"TAGG\" , \"CCTA\" , # reverse complements error \"TCCG\" , \"TCCG\" , # duplicate overhangs error \"CACC\" , # weakest correct warning \"GACT\" , # self-misannealing warning \"ATGG\" , \"CCAG\" , # misannealing pair warning ]","title":"Module overhang"},{"location":"reference/overhang/#sub-modules","text":"overhang.Overhang overhang.OverhangSet overhang.reports overhang.tools overhang.version","title":"Sub-modules"},{"location":"reference/overhang/#variables","text":"DISASTANDARD","title":"Variables"},{"location":"reference/overhang/Overhang/","text":"Module overhang.Overhang View Source import minotaor from .tools import gc_content , order_overhangs , generate_overhang_pairs class Overhang : \"\"\"Class for an overhang and its reverse complement. Note that the overhang with the lower order (e.g. AATA < TATT) will be stored in `Overhang.overhang` and the reverse complement in `Overhang.overhang_rc`, regardless of which was given as parameter. **Parameters** **seq** > ACGT sequence (`str`). \"\"\" def __init__ ( self , seq ): self . overhang , self . overhang_rc = order_overhangs ( seq ) if len ( set ([ self . overhang , self . overhang_rc ])) == 1 : self . is_palindromic = True else : self . is_palindromic = False # its reverse complement has the same GC content: self . gc_content = gc_content ( seq ) self . aa_patterns = minotaor . convert_dna_to_aa_pattern ( self . overhang ) self . count_max_repeat () self . find_codons () def is_good ( self ): \"\"\"Summarise attributes and decide whether overhang can be used for assembly.\"\"\" return not any ([ self . is_palindromic ]) def count_max_repeat ( self , repeat = 3 ): \"\"\"Check overhang for repeating letters. **Parameters** **repeat** > Number of minimum repeats to flag (`int`). For example, 3 checks for AAA etc. \"\"\" for letter in \"ATCG\" : if self . overhang . count ( letter * repeat ) != 0 : self . has_multimer = True return self . has_multimer = False def find_codons ( self ): \"\"\"Check overhang for presence of start and stop codons. This is important information on the suitability of an overhang. \"\"\" start = [ \"ATG\" ] stop = [ \"TAA\" , \"TAG\" , \"TGA\" ] for codon in start : if self . overhang . count ( codon ) != 0 : self . has_start_codon = True else : self . has_start_codon = False for codon in stop : # \"ATGA\" can have both if self . overhang . count ( codon ) != 0 : self . has_stop_codon = True else : self . has_stop_codon = False for codon in start : if self . overhang_rc . count ( codon ) != 0 : self . has_rc_start_codon = True else : self . has_rc_start_codon = False for codon in stop : # \"ATGA\" can have both if self . overhang_rc . count ( codon ) != 0 : self . has_rc_stop_codon = True else : self . has_rc_stop_codon = False def generate_all_overhangs ( overhang_length = 4 ): \"\"\"Generate list Overhang class instances for all overhangs of given length. **Parameters** **overhang_length** > Length of overhangs (`int`). \"\"\" overhang_pairs = generate_overhang_pairs ( overhang_length = overhang_length ) overhang_strings = [ next ( iter ( overhang_pair )) for overhang_pair in overhang_pairs ] overhang_strings . sort () overhangs = [] for overhang_string in overhang_strings : overhang_class = Overhang ( overhang_string ) overhangs += [ overhang_class ] return overhangs def get_overhang_distance ( oh1 , oh2 ): \"\"\"Calculate number of different letters between two Overhang instances. **Parameters** **oh1** > An `Overhang` instance. **oh2 > An `Overhang` instance. \"\"\" distance = get_hamming_distance ( oh1 . overhang , oh2 . overhang ) distance_rc = get_hamming_distance ( oh1 . overhang , oh2 . overhang_rc ) if distance < distance_rc : # we want to find the most similar ones return distance else : return distance_rc def get_hamming_distance ( seq1 , seq2 ): \"\"\"Calculate Hamming distance between two overhang sequences. **Parameters** **seq1** > ACGT sequence (`str`). **seq2** > ACGT sequence (`str`). \"\"\" distance = 0 for i , letter in enumerate ( seq1 ): if letter != seq2 [ i ]: distance += 1 return distance Functions generate_all_overhangs def generate_all_overhangs ( overhang_length = 4 ) Generate list Overhang class instances for all overhangs of given length. Parameters overhang_length Length of overhangs ( int ). View Source def generate_all_overhangs ( overhang_length = 4 ) : \" \"\" Generate list Overhang class instances for all overhangs of given length. **Parameters** **overhang_length** > Length of overhangs (`int`). \"\" \" overhang_pairs = generate_overhang_pairs ( overhang_length = overhang_length ) overhang_strings = [ next ( iter ( overhang_pair )) for overhang_pair in overhang_pairs ] overhang_strings . sort () overhangs = [] for overhang_string in overhang_strings : overhang_class = Overhang ( overhang_string ) overhangs += [ overhang_class ] return overhangs get_hamming_distance def get_hamming_distance ( seq1 , seq2 ) Calculate Hamming distance between two overhang sequences. Parameters seq1 ACGT sequence ( str ). seq2 ACGT sequence ( str ). View Source def get_hamming_distance ( seq1 , seq2 ) : \" \"\" Calculate Hamming distance between two overhang sequences. **Parameters** **seq1** > ACGT sequence (`str`). **seq2** > ACGT sequence (`str`). \"\" \" distance = 0 for i , letter in enumerate ( seq1 ) : if letter != seq2 [ i ] : distance += 1 return distance get_overhang_distance def get_overhang_distance ( oh1 , oh2 ) Calculate number of different letters between two Overhang instances. Parameters oh1 An Overhang instance. **oh2 An Overhang instance. View Source def get_overhang_distance ( oh1 , oh2 ) : \" \"\" Calculate number of different letters between two Overhang instances. **Parameters** **oh1** > An `Overhang` instance. **oh2 > An `Overhang` instance. \"\" \" distance = get_hamming_distance ( oh1 . overhang , oh2 . overhang ) distance_rc = get_hamming_distance ( oh1 . overhang , oh2 . overhang_rc ) if distance < distance_rc : # we want to find the most similar ones return distance else : return distance_rc Classes Overhang class Overhang ( seq ) Class for an overhang and its reverse complement. Note that the overhang with the lower order (e.g. AATA < TATT) will be stored in Overhang.overhang and the reverse complement in Overhang.overhang_rc , regardless of which was given as parameter. Parameters seq ACGT sequence ( str ). View Source class Overhang : \" \"\" Class for an overhang and its reverse complement. Note that the overhang with the lower order (e.g. AATA < TATT) will be stored in `Overhang.overhang` and the reverse complement in `Overhang.overhang_rc`, regardless of which was given as parameter. **Parameters** **seq** > ACGT sequence (`str`). \"\" \" def __init__ ( self , seq ) : self . overhang , self . overhang_rc = order_overhangs ( seq ) if len ( set ( [ self . overhang , self . overhang_rc ] )) == 1 : self . is_palindromic = True else : self . is_palindromic = False # its reverse complement has the same GC content: self . gc_content = gc_content ( seq ) self . aa_patterns = minotaor . convert_dna_to_aa_pattern ( self . overhang ) self . count_max_repeat () self . find_codons () def is_good ( self ) : \" \"\" Summarise attributes and decide whether overhang can be used for assembly. \"\" \" return not any ( [ self . is_palindromic ] ) def count_max_repeat ( self , repeat = 3 ) : \" \"\" Check overhang for repeating letters. **Parameters** **repeat** > Number of minimum repeats to flag (`int`). For example, 3 checks for AAA etc. \"\" \" for letter in \"ATCG\" : if self . overhang . count ( letter * repeat ) != 0 : self . has_multimer = True return self . has_multimer = False def find_codons ( self ) : \" \"\" Check overhang for presence of start and stop codons. This is important information on the suitability of an overhang. \"\" \" start = [ \"ATG\" ] stop = [ \"TAA\" , \"TAG\" , \"TGA\" ] for codon in start : if self . overhang . count ( codon ) != 0 : self . has_start_codon = True else : self . has_start_codon = False for codon in stop : # \"ATGA\" can have both if self . overhang . count ( codon ) != 0 : self . has_stop_codon = True else : self . has_stop_codon = False for codon in start : if self . overhang_rc . count ( codon ) != 0 : self . has_rc_start_codon = True else : self . has_rc_start_codon = False for codon in stop : # \"ATGA\" can have both if self . overhang_rc . count ( codon ) != 0 : self . has_rc_stop_codon = True else : self . has_rc_stop_codon = False Methods count_max_repeat def count_max_repeat ( self , repeat = 3 ) Check overhang for repeating letters. Parameters repeat Number of minimum repeats to flag ( int ). For example, 3 checks for AAA etc. View Source def count_max_repeat ( self , repeat = 3 ) : \" \"\" Check overhang for repeating letters. **Parameters** **repeat** > Number of minimum repeats to flag (`int`). For example, 3 checks for AAA etc. \"\" \" for letter in \"ATCG\" : if self . overhang . count ( letter * repeat ) != 0 : self . has_multimer = True return self . has_multimer = False find_codons def find_codons ( self ) Check overhang for presence of start and stop codons. This is important information on the suitability of an overhang. View Source def find_codons ( self ) : \"\"\" Check overhang for presence of start and stop codons. This is important information on the suitability of an overhang . \"\"\" start = [ \" ATG \" ] stop = [ \" TAA \" , \" TAG \" , \" TGA \" ] for codon in start : if self . overhang . count ( codon ) != 0 : self . has_start_codon = True else : self . has_start_codon = False for codon in stop : # \" ATGA \" can have both if self . overhang . count ( codon ) != 0 : self . has_stop_codon = True else : self . has_stop_codon = False for codon in start : if self . overhang_rc . count ( codon ) != 0 : self . has_rc_start_codon = True else : self . has_rc_start_codon = False for codon in stop : # \" ATGA \" can have both if self . overhang_rc . count ( codon ) != 0 : self . has_rc_stop_codon = True else : self . has_rc_stop_codon = False is_good def is_good ( self ) Summarise attributes and decide whether overhang can be used for assembly. View Source def is_good ( self ) : \"\"\" Summarise attributes and decide whether overhang can be used for assembly. \"\"\" return not any ( [ self . is_palindromic ] )","title":"Overhang"},{"location":"reference/overhang/Overhang/#module-overhangoverhang","text":"View Source import minotaor from .tools import gc_content , order_overhangs , generate_overhang_pairs class Overhang : \"\"\"Class for an overhang and its reverse complement. Note that the overhang with the lower order (e.g. AATA < TATT) will be stored in `Overhang.overhang` and the reverse complement in `Overhang.overhang_rc`, regardless of which was given as parameter. **Parameters** **seq** > ACGT sequence (`str`). \"\"\" def __init__ ( self , seq ): self . overhang , self . overhang_rc = order_overhangs ( seq ) if len ( set ([ self . overhang , self . overhang_rc ])) == 1 : self . is_palindromic = True else : self . is_palindromic = False # its reverse complement has the same GC content: self . gc_content = gc_content ( seq ) self . aa_patterns = minotaor . convert_dna_to_aa_pattern ( self . overhang ) self . count_max_repeat () self . find_codons () def is_good ( self ): \"\"\"Summarise attributes and decide whether overhang can be used for assembly.\"\"\" return not any ([ self . is_palindromic ]) def count_max_repeat ( self , repeat = 3 ): \"\"\"Check overhang for repeating letters. **Parameters** **repeat** > Number of minimum repeats to flag (`int`). For example, 3 checks for AAA etc. \"\"\" for letter in \"ATCG\" : if self . overhang . count ( letter * repeat ) != 0 : self . has_multimer = True return self . has_multimer = False def find_codons ( self ): \"\"\"Check overhang for presence of start and stop codons. This is important information on the suitability of an overhang. \"\"\" start = [ \"ATG\" ] stop = [ \"TAA\" , \"TAG\" , \"TGA\" ] for codon in start : if self . overhang . count ( codon ) != 0 : self . has_start_codon = True else : self . has_start_codon = False for codon in stop : # \"ATGA\" can have both if self . overhang . count ( codon ) != 0 : self . has_stop_codon = True else : self . has_stop_codon = False for codon in start : if self . overhang_rc . count ( codon ) != 0 : self . has_rc_start_codon = True else : self . has_rc_start_codon = False for codon in stop : # \"ATGA\" can have both if self . overhang_rc . count ( codon ) != 0 : self . has_rc_stop_codon = True else : self . has_rc_stop_codon = False def generate_all_overhangs ( overhang_length = 4 ): \"\"\"Generate list Overhang class instances for all overhangs of given length. **Parameters** **overhang_length** > Length of overhangs (`int`). \"\"\" overhang_pairs = generate_overhang_pairs ( overhang_length = overhang_length ) overhang_strings = [ next ( iter ( overhang_pair )) for overhang_pair in overhang_pairs ] overhang_strings . sort () overhangs = [] for overhang_string in overhang_strings : overhang_class = Overhang ( overhang_string ) overhangs += [ overhang_class ] return overhangs def get_overhang_distance ( oh1 , oh2 ): \"\"\"Calculate number of different letters between two Overhang instances. **Parameters** **oh1** > An `Overhang` instance. **oh2 > An `Overhang` instance. \"\"\" distance = get_hamming_distance ( oh1 . overhang , oh2 . overhang ) distance_rc = get_hamming_distance ( oh1 . overhang , oh2 . overhang_rc ) if distance < distance_rc : # we want to find the most similar ones return distance else : return distance_rc def get_hamming_distance ( seq1 , seq2 ): \"\"\"Calculate Hamming distance between two overhang sequences. **Parameters** **seq1** > ACGT sequence (`str`). **seq2** > ACGT sequence (`str`). \"\"\" distance = 0 for i , letter in enumerate ( seq1 ): if letter != seq2 [ i ]: distance += 1 return distance","title":"Module overhang.Overhang"},{"location":"reference/overhang/Overhang/#functions","text":"","title":"Functions"},{"location":"reference/overhang/Overhang/#generate_all_overhangs","text":"def generate_all_overhangs ( overhang_length = 4 ) Generate list Overhang class instances for all overhangs of given length. Parameters overhang_length Length of overhangs ( int ). View Source def generate_all_overhangs ( overhang_length = 4 ) : \" \"\" Generate list Overhang class instances for all overhangs of given length. **Parameters** **overhang_length** > Length of overhangs (`int`). \"\" \" overhang_pairs = generate_overhang_pairs ( overhang_length = overhang_length ) overhang_strings = [ next ( iter ( overhang_pair )) for overhang_pair in overhang_pairs ] overhang_strings . sort () overhangs = [] for overhang_string in overhang_strings : overhang_class = Overhang ( overhang_string ) overhangs += [ overhang_class ] return overhangs","title":"generate_all_overhangs"},{"location":"reference/overhang/Overhang/#get_hamming_distance","text":"def get_hamming_distance ( seq1 , seq2 ) Calculate Hamming distance between two overhang sequences. Parameters seq1 ACGT sequence ( str ). seq2 ACGT sequence ( str ). View Source def get_hamming_distance ( seq1 , seq2 ) : \" \"\" Calculate Hamming distance between two overhang sequences. **Parameters** **seq1** > ACGT sequence (`str`). **seq2** > ACGT sequence (`str`). \"\" \" distance = 0 for i , letter in enumerate ( seq1 ) : if letter != seq2 [ i ] : distance += 1 return distance","title":"get_hamming_distance"},{"location":"reference/overhang/Overhang/#get_overhang_distance","text":"def get_overhang_distance ( oh1 , oh2 ) Calculate number of different letters between two Overhang instances. Parameters oh1 An Overhang instance. **oh2 An Overhang instance. View Source def get_overhang_distance ( oh1 , oh2 ) : \" \"\" Calculate number of different letters between two Overhang instances. **Parameters** **oh1** > An `Overhang` instance. **oh2 > An `Overhang` instance. \"\" \" distance = get_hamming_distance ( oh1 . overhang , oh2 . overhang ) distance_rc = get_hamming_distance ( oh1 . overhang , oh2 . overhang_rc ) if distance < distance_rc : # we want to find the most similar ones return distance else : return distance_rc","title":"get_overhang_distance"},{"location":"reference/overhang/Overhang/#classes","text":"","title":"Classes"},{"location":"reference/overhang/Overhang/#overhang","text":"class Overhang ( seq ) Class for an overhang and its reverse complement. Note that the overhang with the lower order (e.g. AATA < TATT) will be stored in Overhang.overhang and the reverse complement in Overhang.overhang_rc , regardless of which was given as parameter. Parameters seq ACGT sequence ( str ). View Source class Overhang : \" \"\" Class for an overhang and its reverse complement. Note that the overhang with the lower order (e.g. AATA < TATT) will be stored in `Overhang.overhang` and the reverse complement in `Overhang.overhang_rc`, regardless of which was given as parameter. **Parameters** **seq** > ACGT sequence (`str`). \"\" \" def __init__ ( self , seq ) : self . overhang , self . overhang_rc = order_overhangs ( seq ) if len ( set ( [ self . overhang , self . overhang_rc ] )) == 1 : self . is_palindromic = True else : self . is_palindromic = False # its reverse complement has the same GC content: self . gc_content = gc_content ( seq ) self . aa_patterns = minotaor . convert_dna_to_aa_pattern ( self . overhang ) self . count_max_repeat () self . find_codons () def is_good ( self ) : \" \"\" Summarise attributes and decide whether overhang can be used for assembly. \"\" \" return not any ( [ self . is_palindromic ] ) def count_max_repeat ( self , repeat = 3 ) : \" \"\" Check overhang for repeating letters. **Parameters** **repeat** > Number of minimum repeats to flag (`int`). For example, 3 checks for AAA etc. \"\" \" for letter in \"ATCG\" : if self . overhang . count ( letter * repeat ) != 0 : self . has_multimer = True return self . has_multimer = False def find_codons ( self ) : \" \"\" Check overhang for presence of start and stop codons. This is important information on the suitability of an overhang. \"\" \" start = [ \"ATG\" ] stop = [ \"TAA\" , \"TAG\" , \"TGA\" ] for codon in start : if self . overhang . count ( codon ) != 0 : self . has_start_codon = True else : self . has_start_codon = False for codon in stop : # \"ATGA\" can have both if self . overhang . count ( codon ) != 0 : self . has_stop_codon = True else : self . has_stop_codon = False for codon in start : if self . overhang_rc . count ( codon ) != 0 : self . has_rc_start_codon = True else : self . has_rc_start_codon = False for codon in stop : # \"ATGA\" can have both if self . overhang_rc . count ( codon ) != 0 : self . has_rc_stop_codon = True else : self . has_rc_stop_codon = False","title":"Overhang"},{"location":"reference/overhang/Overhang/#methods","text":"","title":"Methods"},{"location":"reference/overhang/Overhang/#count_max_repeat","text":"def count_max_repeat ( self , repeat = 3 ) Check overhang for repeating letters. Parameters repeat Number of minimum repeats to flag ( int ). For example, 3 checks for AAA etc. View Source def count_max_repeat ( self , repeat = 3 ) : \" \"\" Check overhang for repeating letters. **Parameters** **repeat** > Number of minimum repeats to flag (`int`). For example, 3 checks for AAA etc. \"\" \" for letter in \"ATCG\" : if self . overhang . count ( letter * repeat ) != 0 : self . has_multimer = True return self . has_multimer = False","title":"count_max_repeat"},{"location":"reference/overhang/Overhang/#find_codons","text":"def find_codons ( self ) Check overhang for presence of start and stop codons. This is important information on the suitability of an overhang. View Source def find_codons ( self ) : \"\"\" Check overhang for presence of start and stop codons. This is important information on the suitability of an overhang . \"\"\" start = [ \" ATG \" ] stop = [ \" TAA \" , \" TAG \" , \" TGA \" ] for codon in start : if self . overhang . count ( codon ) != 0 : self . has_start_codon = True else : self . has_start_codon = False for codon in stop : # \" ATGA \" can have both if self . overhang . count ( codon ) != 0 : self . has_stop_codon = True else : self . has_stop_codon = False for codon in start : if self . overhang_rc . count ( codon ) != 0 : self . has_rc_start_codon = True else : self . has_rc_start_codon = False for codon in stop : # \" ATGA \" can have both if self . overhang_rc . count ( codon ) != 0 : self . has_rc_stop_codon = True else : self . has_rc_stop_codon = False","title":"find_codons"},{"location":"reference/overhang/Overhang/#is_good","text":"def is_good ( self ) Summarise attributes and decide whether overhang can be used for assembly. View Source def is_good ( self ) : \"\"\" Summarise attributes and decide whether overhang can be used for assembly. \"\"\" return not any ( [ self . is_palindromic ] )","title":"is_good"},{"location":"reference/overhang/OverhangSet/","text":"Module overhang.OverhangSet View Source import itertools import networkx import tatapov from .Overhang import Overhang , get_overhang_distance from .tools import reverse_complement , enzyme_tatapov_lookup class OverhangSet : \"\"\"Class for *overhang sets*. An overhang set is a collection of (mutually compatible) overhangs used for DNA assembly. **Parameters** **overhangs** > A list of overhang strings (`list`). Example: `[\"TAGG\", \"ATGG\", \"GACT\"]`. **enzyme** > Enzyme used for assembly (`str`). Example: `\"Esp3I\"`. **name** > Name of the set (`str`). \"\"\" def __init__ ( self , overhangs , enzyme = \"Esp3I\" , name = \"Unnamed set\" ): self . overhangs = [ Overhang ( overhang ) for overhang in overhangs ] if len ( set ( overhangs )) != len ( overhangs ): self . has_duplicates = True else : self . has_duplicates = False self . overhang_input = overhangs self . overhang_input_txt = \", \" . join ( self . overhang_input ) self . enzyme = enzyme self . name = name self . has_warnings = False # used during evaluation of set and reporting self . has_errors = False # used during evaluation of set and reporting self . overhang_length = len ( self . overhang_input [ 0 ]) def inspect_overhangs ( self , make_plot = True ): \"\"\"Inspect compatibility of overhangs and detect potential errors in the set.\"\"\" # DUPLICATES if self . has_duplicates : print ( \"Incorrect set! Duplicate overhangs\" ) self . has_errors = True # PALINDROMIC self . palindromic_oh = [] self . palindromic_oh += [ overhang . overhang for overhang in self . overhangs if overhang . is_palindromic ] if len ( self . palindromic_oh ) != 0 : self . palindromic_text = \"Palindromic overhang(s): \" + \"; \" . join ( self . palindromic_oh ) print (( \"Incorrect set! \" + self . palindromic_text )) self . has_errors = True # REVERSE COMPLEMENT nonpalindromic_oh = set ( self . overhang_input ) - set ( self . palindromic_oh ) nonpalindromic_oh_rc = { reverse_complement ( oh ) for oh in nonpalindromic_oh } rc_oh = nonpalindromic_oh & nonpalindromic_oh_rc if rc_oh : self . has_rc_error = True self . rc_error_text = ( \"Nonpalindromic overhang(s) with reverse complement: \" + \"; \" . join ( rc_oh ) ) print (( \"Incorrect set! \" + self . rc_error_text )) self . has_errors = True else : self . has_rc_error = False # SIMILAR OVERHANGS -- we do not consider it as a flaw self . similar_overhangs = self . find_similar_overhangs () # SET SIZE # Based on Pryor et al., PLoS ONE (2020): if self . overhang_length == 3 : # check overhang length on first one n = 10 if len ( self . overhang_input ) > n : self . set_size_text = ( \"Assembly fidelity significantly decreases when using \" + \"more than %d overhangs.\" % n ) # text used in report print ( \"Warning! \" + self . set_size_text ) elif self . overhang_length == 4 : n = 20 if len ( self . overhang_input ) > n : self . set_size_text = ( \"Assembly fidelity significantly decreases when using \" + \"more than %d overhangs.\" % n ) print ( \"Warning! \" + self . set_size_text ) else : self . set_size_text = \"\" # MISANNEALING self . evaluate_annealing () # also sets `has_warnings` # Tatapov plots: if make_plot : figwidth = len ( self . overhang_input ) print ( self . enzyme , \"Tatapov plot (37 Celsius, 1 hour):\" ) data = tatapov . annealing_data [ \"37C\" ][ enzyme_tatapov_lookup [ self . enzyme ]] subset = tatapov . data_subset ( data , self . overhang_input , add_reverse = True ) self . ax , _ = tatapov . plot_data ( subset , figwidth = figwidth , plot_color = \"Reds\" ) self . ax . figure . tight_layout () self . ax . plot () def evaluate_annealing ( self ): \"\"\"Evaluate weakly anneals, self-misanneals and misanneals between overhangs. Used in `inspect_overhangs()`. \"\"\" # Prepare data: data = tatapov . annealing_data [ \"37C\" ][ enzyme_tatapov_lookup [ self . enzyme ]] subset = tatapov . data_subset ( data , self . overhang_input , add_reverse = True ) # WEAK ANNEALS # See cutoff 400 in Pryor et al. Figure 2. self . weak_anneals_list = [ [ oh . overhang , oh . overhang_rc ] for oh in self . overhangs if subset [ oh . overhang ][ oh . overhang_rc ] < 400 ] # Convert to text self . weak_anneals = [ oh_pair [ 0 ] + \"/\" + oh_pair [ 1 ] for oh_pair in self . weak_anneals_list ] self . weak_anneals = \"; \" . join ( self . weak_anneals ) if not self . weak_anneals == \"\" : self . has_warnings = True # SELF-MISANNEALS self . self_misanneals_list = [ [ oh . overhang , oh . overhang_rc ] for oh in self . overhangs if subset [ oh . overhang ][ oh . overhang ] != 0 or subset [ oh . overhang_rc ][ oh . overhang_rc ] != 0 ] self . self_misanneals = [ oh_pair [ 0 ] + \"/\" + oh_pair [ 1 ] for oh_pair in self . self_misanneals_list ] self . self_misanneals = \"; \" . join ( self . self_misanneals ) if not self . self_misanneals == \"\" : self . has_warnings = True # MISANNEALS self . misanneals_list = [] for oh1 , oh2 in itertools . combinations ( self . overhangs , 2 ): # 10 below is a good cutoff for misannealing pairs if ( subset . loc [ [ oh1 . overhang , oh1 . overhang_rc ], [ oh2 . overhang , oh2 . overhang_rc ] ] > 10 ) . any ( axis = None ): # oh and reverse complement, in a list with its misannealing pair self . misanneals_list += [ [[ oh1 . overhang , oh1 . overhang_rc ], [ oh2 . overhang , oh2 . overhang_rc ]] ] # Create a text from the 4 overhangs, for the report: self . misanneals = [ misannealing_pair [ 0 ][ 0 ] + \"/\" + misannealing_pair [ 0 ][ 1 ] + \" ~ \" + misannealing_pair [ 1 ][ 0 ] + \"/\" + misannealing_pair [ 1 ][ 1 ] for misannealing_pair in self . misanneals_list ] self . misanneals = \"; \" . join ( self . misanneals ) if not self . misanneals == \"\" : self . has_warnings = True def find_similar_overhangs ( self , difference_threshold = None ): \"\"\"Find overhangs that differ in fewer nucleotides than the threshold. **Parameters** **difference_threshold** > Acceptable number of matching nucleotides in an overhang pair (`int`). Overhang pairs with fewer differences are marked as similar. Defaults to 0. \"\"\" if difference_threshold is None : difference_threshold = 0 similar_overhangs = \"\" for oh1 , oh2 in itertools . combinations ( self . overhangs , 2 ): if get_overhang_distance ( oh1 , oh2 ) < difference_threshold : similar_overhangs += ( oh1 . overhang + \"/\" + oh1 . overhang_rc + \" ~ \" + oh2 . overhang + \"/\" + oh2 . overhang_rc + \" ; \" ) if similar_overhangs == \"\" : similar_overhangs = ( \"No overhangs (including reverse complements) \" \"differ by fewer than %d nucleotides.\" % difference_threshold ) else : similar_overhangs = ( \"These overhang pairs (including reverse complements) have fewer than \" \" %d differences: \" % difference_threshold + similar_overhangs ) return similar_overhangs def find_perfect_subset ( self ): \"\"\"\"Find a better overhang set by removing bad overhang interactions. Bad interactions are weak anneals, self-misanneals and misanneals. \"\"\" self . inspect_overhangs ( make_plot = False ) # REMOVE WEAK oh_to_remove = [ oh for oh_pair in self . weak_anneals_list for oh in oh_pair ] self . subset = set ( self . overhang_input ) - set ( oh_to_remove ) # REMOVE SELF-MISANNEALING oh_to_remove = [ oh for oh_pair in self . self_misanneals_list for oh in oh_pair ] self . subset = set ( self . subset ) - set ( oh_to_remove ) # REMOVE MISANNEALING compatible_overhangs = [] misanneals_for_loop = [ pair [ 0 ] + pair [ 1 ] for pair in self . misanneals_list ] for oh1 , oh2 in itertools . combinations ( self . subset , 2 ): add_oh = True for pair in misanneals_for_loop : if oh1 in pair and oh2 in pair : add_oh = False break if add_oh : compatible_overhangs += [( oh1 , oh2 )] graph = networkx . Graph ( compatible_overhangs ) max_clique , clique_size = networkx . max_weight_clique ( graph , None ) self . subset = max_clique print ( \"Overhangs in subset: \" + str ( self . subset )) print ( \"Number of overhangs in subset: \" + str ( clique_size )) # Visualize subset: figwidth = len ( self . subset ) print ( self . enzyme , \"Tatapov plot (37 Celsius, 1 hour):\" ) data = tatapov . annealing_data [ \"37C\" ][ enzyme_tatapov_lookup [ self . enzyme ]] subset = tatapov . data_subset ( data , self . subset , add_reverse = True ) self . ax , _ = tatapov . plot_data ( subset , figwidth = figwidth , plot_color = \"Reds\" ) self . ax . figure . tight_layout () self . ax . plot () Variables enzyme_tatapov_lookup Classes OverhangSet class OverhangSet ( overhangs , enzyme = 'Esp3I' , name = 'Unnamed set' ) Class for overhang sets . An overhang set is a collection of (mutually compatible) overhangs used for DNA assembly. Parameters overhangs A list of overhang strings ( list ). Example: [\"TAGG\", \"ATGG\", \"GACT\"] . enzyme Enzyme used for assembly ( str ). Example: \"Esp3I\" . name Name of the set ( str ). View Source class OverhangSet : \" \"\" Class for *overhang sets*. An overhang set is a collection of (mutually compatible) overhangs used for DNA assembly. **Parameters** **overhangs** > A list of overhang strings (`list`). Example: `[\" TAGG \", \" ATGG \", \" GACT \"]`. **enzyme** > Enzyme used for assembly (`str`). Example: `\" Esp3I \"`. **name** > Name of the set (`str`). \"\" \" def __init__ ( self , overhangs , enzyme = \"Esp3I\" , name = \"Unnamed set\" ) : self . overhangs = [ Overhang ( overhang ) for overhang in overhangs ] if len ( set ( overhangs )) != len ( overhangs ) : self . has_duplicates = True else : self . has_duplicates = False self . overhang_input = overhangs self . overhang_input_txt = \", \" . join ( self . overhang_input ) self . enzyme = enzyme self . name = name self . has_warnings = False # used during evaluation of set and reporting self . has_errors = False # used during evaluation of set and reporting self . overhang_length = len ( self . overhang_input [ 0 ] ) def inspect_overhangs ( self , make_plot = True ) : \" \"\" Inspect compatibility of overhangs and detect potential errors in the set. \"\" \" # DUPLICATES if self . has_duplicates : print ( \"Incorrect set! Duplicate overhangs\" ) self . has_errors = True # PALINDROMIC self . palindromic_oh = [] self . palindromic_oh += [ overhang . overhang for overhang in self . overhangs if overhang . is_palindromic ] if len ( self . palindromic_oh ) != 0 : self . palindromic_text = \"Palindromic overhang(s): \" + \"; \" . join ( self . palindromic_oh ) print (( \"Incorrect set! \" + self . palindromic_text )) self . has_errors = True # REVERSE COMPLEMENT nonpalindromic_oh = set ( self . overhang_input ) - set ( self . palindromic_oh ) nonpalindromic_oh_rc = { reverse_complement ( oh ) for oh in nonpalindromic_oh } rc_oh = nonpalindromic_oh & nonpalindromic_oh_rc if rc_oh : self . has_rc_error = True self . rc_error_text = ( \"Nonpalindromic overhang(s) with reverse complement: \" + \"; \" . join ( rc_oh ) ) print (( \"Incorrect set! \" + self . rc_error_text )) self . has_errors = True else : self . has_rc_error = False # SIMILAR OVERHANGS -- we do not consider it as a flaw self . similar_overhangs = self . find_similar_overhangs () # SET SIZE # Based on Pryor et al., PLoS ONE (2020): if self . overhang_length == 3 : # check overhang length on first one n = 10 if len ( self . overhang_input ) > n : self . set _size_text = ( \"Assembly fidelity significantly decreases when using \" + \"more than %d overhangs.\" % n ) # text used in report print ( \"Warning! \" + self . set _size_text ) elif self . overhang_length == 4 : n = 20 if len ( self . overhang_input ) > n : self . set _size_text = ( \"Assembly fidelity significantly decreases when using \" + \"more than %d overhangs.\" % n ) print ( \"Warning! \" + self . set _size_text ) else : self . set _size_text = \"\" # MISANNEALING self . evaluate_annealing () # also sets `has_warnings` # Tatapov plots: if make_plot : figwidth = len ( self . overhang_input ) print ( self . enzyme , \"Tatapov plot (37 Celsius, 1 hour):\" ) data = tatapov . annealing_data [ \"37C\" ][ enzyme_tatapov_lookup [ self . enzyme ]] subset = tatapov . data_subset ( data , self . overhang_input , add_reverse = True ) self . ax , _ = tatapov . plot_data ( subset , figwidth = figwidth , plot_color = \"Reds\" ) self . ax . figure . tight_layout () self . ax . plot () def evaluate_annealing ( self ) : \" \"\" Evaluate weakly anneals, self-misanneals and misanneals between overhangs. Used in `inspect_overhangs()`. \"\" \" # Prepare data: data = tatapov . annealing_data [ \"37C\" ][ enzyme_tatapov_lookup [ self . enzyme ]] subset = tatapov . data_subset ( data , self . overhang_input , add_reverse = True ) # WEAK ANNEALS # See cutoff 400 in Pryor et al. Figure 2. self . weak_anneals_list = [ [ oh . overhang , oh . overhang_rc ] for oh in self . overhangs if subset [ oh . overhang ][ oh . overhang_rc ] < 400 ] # Convert to text self . weak_anneals = [ oh_pair [ 0 ] + \"/\" + oh_pair [ 1 ] for oh_pair in self . weak_anneals_list ] self . weak_anneals = \"; \" . join ( self . weak_anneals ) if not self . weak_anneals == \"\" : self . has_warnings = True # SELF-MISANNEALS self . self_misanneals_list = [ [ oh . overhang , oh . overhang_rc ] for oh in self . overhangs if subset [ oh . overhang ][ oh . overhang ] != 0 or subset [ oh . overhang_rc ][ oh . overhang_rc ] != 0 ] self . self_misanneals = [ oh_pair [ 0 ] + \"/\" + oh_pair [ 1 ] for oh_pair in self . self_misanneals_list ] self . self_misanneals = \"; \" . join ( self . self_misanneals ) if not self . self_misanneals == \"\" : self . has_warnings = True # MISANNEALS self . misanneals_list = [] for oh1 , oh2 in itertools . combinations ( self . overhangs , 2 ) : # 10 below is a good cutoff for misannealing pairs if ( subset . loc [ [ oh1 . overhang , oh1 . overhang_rc ] , [ oh2 . overhang , oh2 . overhang_rc ] ] > 10 ). any ( axis = None ) : # oh and reverse complement, in a list with its misannealing pair self . misanneals_list += [ [[ oh1 . overhang , oh1 . overhang_rc ] , [ oh2 . overhang , oh2 . overhang_rc ]] ] # Create a text from the 4 overhangs, for the report: self . misanneals = [ misannealing_pair [ 0 ][ 0 ] + \"/\" + misannealing_pair [ 0 ][ 1 ] + \" ~ \" + misannealing_pair [ 1 ][ 0 ] + \"/\" + misannealing_pair [ 1 ][ 1 ] for misannealing_pair in self . misanneals_list ] self . misanneals = \"; \" . join ( self . misanneals ) if not self . misanneals == \"\" : self . has_warnings = True def find_similar_overhangs ( self , difference_threshold = None ) : \" \"\" Find overhangs that differ in fewer nucleotides than the threshold. **Parameters** **difference_threshold** > Acceptable number of matching nucleotides in an overhang pair (`int`). Overhang pairs with fewer differences are marked as similar. Defaults to 0. \"\" \" if difference_threshold is None : difference_threshold = 0 similar_overhangs = \"\" for oh1 , oh2 in itertools . combinations ( self . overhangs , 2 ) : if get_overhang_distance ( oh1 , oh2 ) < difference_threshold : similar_overhangs += ( oh1 . overhang + \"/\" + oh1 . overhang_rc + \" ~ \" + oh2 . overhang + \"/\" + oh2 . overhang_rc + \" ; \" ) if similar_overhangs == \"\" : similar_overhangs = ( \"No overhangs (including reverse complements) \" \"differ by fewer than %d nucleotides.\" % difference_threshold ) else : similar_overhangs = ( \"These overhang pairs (including reverse complements) have fewer than \" \"%d differences: \" % difference_threshold + similar_overhangs ) return similar_overhangs def find_perfect_subset ( self ) : \" \"\" \" Find a better overhang set by removing bad overhang interactions . Bad interactions are weak anneals , self - misanneals and misanneals . \" \"\" self.inspect_overhangs(make_plot=False) # REMOVE WEAK oh_to_remove = [oh for oh_pair in self.weak_anneals_list for oh in oh_pair] self.subset = set(self.overhang_input) - set(oh_to_remove) # REMOVE SELF-MISANNEALING oh_to_remove = [oh for oh_pair in self.self_misanneals_list for oh in oh_pair] self.subset = set(self.subset) - set(oh_to_remove) # REMOVE MISANNEALING compatible_overhangs = [] misanneals_for_loop = [pair[0] + pair[1] for pair in self.misanneals_list] for oh1, oh2 in itertools.combinations(self.subset, 2): add_oh = True for pair in misanneals_for_loop: if oh1 in pair and oh2 in pair: add_oh = False break if add_oh: compatible_overhangs += [(oh1, oh2)] graph = networkx.Graph(compatible_overhangs) max_clique, clique_size = networkx.max_weight_clique(graph, None) self.subset = max_clique print(\" Overhangs in subset : \" + str(self.subset)) print(\" Number of overhangs in subset : \" + str(clique_size)) # Visualize subset: figwidth = len(self.subset) print(self.enzyme, \" Tatapov plot ( 37 Celsius , 1 hour ) : \") data = tatapov.annealing_data[\" 37C \"][enzyme_tatapov_lookup[self.enzyme]] subset = tatapov.data_subset(data, self.subset, add_reverse=True) self.ax, _ = tatapov.plot_data(subset, figwidth=figwidth, plot_color=\" Reds \") self.ax.figure.tight_layout() self.ax.plot() Methods evaluate_annealing def evaluate_annealing ( self ) Evaluate weakly anneals, self-misanneals and misanneals between overhangs. Used in inspect_overhangs() . View Source def evaluate_annealing ( self ): \"\"\"Evaluate weakly anneals, self-misanneals and misanneals between overhangs. Used in `inspect_overhangs()`. \"\"\" # Prepare data: data = tatapov . annealing_data [ \"37C\" ][ enzyme_tatapov_lookup [ self . enzyme ]] subset = tatapov . data_subset ( data , self . overhang_input , add_reverse = True ) # WEAK ANNEALS # See cutoff 400 in Pryor et al. Figure 2. self . weak_anneals_list = [ [ oh . overhang , oh . overhang_rc ] for oh in self . overhangs if subset [ oh . overhang ][ oh . overhang_rc ] < 400 ] # Convert to text self . weak_anneals = [ oh_pair [ 0 ] + \"/\" + oh_pair [ 1 ] for oh_pair in self . weak_anneals_list ] self . weak_anneals = \"; \" . join ( self . weak_anneals ) if not self . weak_anneals == \"\" : self . has_warnings = True # SELF-MISANNEALS self . self_misanneals_list = [ [ oh . overhang , oh . overhang_rc ] for oh in self . overhangs if subset [ oh . overhang ][ oh . overhang ] != 0 or subset [ oh . overhang_rc ][ oh . overhang_rc ] != 0 ] self . self_misanneals = [ oh_pair [ 0 ] + \"/\" + oh_pair [ 1 ] for oh_pair in self . self_misanneals_list ] self . self_misanneals = \"; \" . join ( self . self_misanneals ) if not self . self_misanneals == \"\" : self . has_warnings = True # MISANNEALS self . misanneals_list = [] for oh1 , oh2 in itertools . combinations ( self . overhangs , 2 ): # 10 below is a good cutoff for misannealing pairs if ( subset . loc [ [ oh1 . overhang , oh1 . overhang_rc ], [ oh2 . overhang , oh2 . overhang_rc ] ] > 10 ) . any ( axis = None ): # oh and reverse complement, in a list with its misannealing pair self . misanneals_list += [ [[ oh1 . overhang , oh1 . overhang_rc ], [ oh2 . overhang , oh2 . overhang_rc ]] ] # Create a text from the 4 overhangs, for the report: self . misanneals = [ misannealing_pair [ 0 ][ 0 ] + \"/\" + misannealing_pair [ 0 ][ 1 ] + \" ~ \" + misannealing_pair [ 1 ][ 0 ] + \"/\" + misannealing_pair [ 1 ][ 1 ] for misannealing_pair in self . misanneals_list ] self . misanneals = \"; \" . join ( self . misanneals ) if not self . misanneals == \"\" : self . has_warnings = True find_perfect_subset def find_perfect_subset ( self ) \"Find a better overhang set by removing bad overhang interactions. Bad interactions are weak anneals, self-misanneals and misanneals. View Source def find_perfect_subset ( self ): \"\"\"\"Find a better overhang set by removing bad overhang interactions. Bad interactions are weak anneals, self-misanneals and misanneals. \"\"\" self . inspect_overhangs ( make_plot = False ) # REMOVE WEAK oh_to_remove = [ oh for oh_pair in self . weak_anneals_list for oh in oh_pair ] self . subset = set ( self . overhang_input ) - set ( oh_to_remove ) # REMOVE SELF-MISANNEALING oh_to_remove = [ oh for oh_pair in self . self_misanneals_list for oh in oh_pair ] self . subset = set ( self . subset ) - set ( oh_to_remove ) # REMOVE MISANNEALING compatible_overhangs = [] misanneals_for_loop = [ pair [ 0 ] + pair [ 1 ] for pair in self . misanneals_list ] for oh1 , oh2 in itertools . combinations ( self . subset , 2 ): add_oh = True for pair in misanneals_for_loop : if oh1 in pair and oh2 in pair : add_oh = False break if add_oh : compatible_overhangs += [( oh1 , oh2 )] graph = networkx . Graph ( compatible_overhangs ) max_clique , clique_size = networkx . max_weight_clique ( graph , None ) self . subset = max_clique print ( \"Overhangs in subset: \" + str ( self . subset )) print ( \"Number of overhangs in subset: \" + str ( clique_size )) # Visualize subset: figwidth = len ( self . subset ) print ( self . enzyme , \"Tatapov plot (37 Celsius, 1 hour):\" ) data = tatapov . annealing_data [ \"37C\" ][ enzyme_tatapov_lookup [ self . enzyme ]] subset = tatapov . data_subset ( data , self . subset , add_reverse = True ) self . ax , _ = tatapov . plot_data ( subset , figwidth = figwidth , plot_color = \"Reds\" ) self . ax . figure . tight_layout () self . ax . plot () find_similar_overhangs def find_similar_overhangs ( self , difference_threshold = None ) Find overhangs that differ in fewer nucleotides than the threshold. Parameters difference_threshold Acceptable number of matching nucleotides in an overhang pair ( int ). Overhang pairs with fewer differences are marked as similar. Defaults to 0. View Source def find_similar_overhangs ( self , difference_threshold = None ) : \" \"\" Find overhangs that differ in fewer nucleotides than the threshold. **Parameters** **difference_threshold** > Acceptable number of matching nucleotides in an overhang pair (`int`). Overhang pairs with fewer differences are marked as similar. Defaults to 0. \"\" \" if difference_threshold is None : difference_threshold = 0 similar_overhangs = \"\" for oh1 , oh2 in itertools . combinations ( self . overhangs , 2 ) : if get_overhang_distance ( oh1 , oh2 ) < difference_threshold : similar_overhangs += ( oh1 . overhang + \"/\" + oh1 . overhang_rc + \" ~ \" + oh2 . overhang + \"/\" + oh2 . overhang_rc + \" ; \" ) if similar_overhangs == \"\" : similar_overhangs = ( \"No overhangs (including reverse complements) \" \"differ by fewer than %d nucleotides.\" % difference_threshold ) else : similar_overhangs = ( \"These overhang pairs (including reverse complements) have fewer than \" \"%d differences: \" % difference_threshold + similar_overhangs ) return similar_overhangs inspect_overhangs def inspect_overhangs ( self , make_plot = True ) Inspect compatibility of overhangs and detect potential errors in the set. View Source def inspect_overhangs ( self , make_plot = True ) : \" \"\" Inspect compatibility of overhangs and detect potential errors in the set. \"\" \" # DUPLICATES if self . has_duplicates : print ( \"Incorrect set! Duplicate overhangs\" ) self . has_errors = True # PALINDROMIC self . palindromic_oh = [] self . palindromic_oh += [ overhang . overhang for overhang in self . overhangs if overhang . is_palindromic ] if len ( self . palindromic_oh ) != 0 : self . palindromic_text = \"Palindromic overhang(s): \" + \"; \" . join ( self . palindromic_oh ) print (( \"Incorrect set! \" + self . palindromic_text )) self . has_errors = True # REVERSE COMPLEMENT nonpalindromic_oh = set ( self . overhang_input ) - set ( self . palindromic_oh ) nonpalindromic_oh_rc = { reverse_complement ( oh ) for oh in nonpalindromic_oh } rc_oh = nonpalindromic_oh & nonpalindromic_oh_rc if rc_oh : self . has_rc_error = True self . rc_error_text = ( \"Nonpalindromic overhang(s) with reverse complement: \" + \"; \" . join ( rc_oh ) ) print (( \"Incorrect set! \" + self . rc_error_text )) self . has_errors = True else : self . has_rc_error = False # SIMILAR OVERHANGS -- we do not consider it as a flaw self . similar_overhangs = self . find_similar_overhangs () # SET SIZE # Based on Pryor et al., PLoS ONE (2020): if self . overhang_length == 3 : # check overhang length on first one n = 10 if len ( self . overhang_input ) > n : self . set _size_text = ( \"Assembly fidelity significantly decreases when using \" + \"more than %d overhangs.\" % n ) # text used in report print ( \"Warning! \" + self . set _size_text ) elif self . overhang_length == 4 : n = 20 if len ( self . overhang_input ) > n : self . set _size_text = ( \"Assembly fidelity significantly decreases when using \" + \"more than %d overhangs.\" % n ) print ( \"Warning! \" + self . set _size_text ) else : self . set _size_text = \"\" # MISANNEALING self . evaluate_annealing () # also sets `has_warnings` # Tatapov plots: if make_plot : figwidth = len ( self . overhang_input ) print ( self . enzyme , \"Tatapov plot (37 Celsius, 1 hour):\" ) data = tatapov . annealing_data [ \"37C\" ][ enzyme_tatapov_lookup [ self . enzyme ]] subset = tatapov . data_subset ( data , self . overhang_input , add_reverse = True ) self . ax , _ = tatapov . plot_data ( subset , figwidth = figwidth , plot_color = \"Reds\" ) self . ax . figure . tight_layout () self . ax . plot ()","title":"Overhangset"},{"location":"reference/overhang/OverhangSet/#module-overhangoverhangset","text":"View Source import itertools import networkx import tatapov from .Overhang import Overhang , get_overhang_distance from .tools import reverse_complement , enzyme_tatapov_lookup class OverhangSet : \"\"\"Class for *overhang sets*. An overhang set is a collection of (mutually compatible) overhangs used for DNA assembly. **Parameters** **overhangs** > A list of overhang strings (`list`). Example: `[\"TAGG\", \"ATGG\", \"GACT\"]`. **enzyme** > Enzyme used for assembly (`str`). Example: `\"Esp3I\"`. **name** > Name of the set (`str`). \"\"\" def __init__ ( self , overhangs , enzyme = \"Esp3I\" , name = \"Unnamed set\" ): self . overhangs = [ Overhang ( overhang ) for overhang in overhangs ] if len ( set ( overhangs )) != len ( overhangs ): self . has_duplicates = True else : self . has_duplicates = False self . overhang_input = overhangs self . overhang_input_txt = \", \" . join ( self . overhang_input ) self . enzyme = enzyme self . name = name self . has_warnings = False # used during evaluation of set and reporting self . has_errors = False # used during evaluation of set and reporting self . overhang_length = len ( self . overhang_input [ 0 ]) def inspect_overhangs ( self , make_plot = True ): \"\"\"Inspect compatibility of overhangs and detect potential errors in the set.\"\"\" # DUPLICATES if self . has_duplicates : print ( \"Incorrect set! Duplicate overhangs\" ) self . has_errors = True # PALINDROMIC self . palindromic_oh = [] self . palindromic_oh += [ overhang . overhang for overhang in self . overhangs if overhang . is_palindromic ] if len ( self . palindromic_oh ) != 0 : self . palindromic_text = \"Palindromic overhang(s): \" + \"; \" . join ( self . palindromic_oh ) print (( \"Incorrect set! \" + self . palindromic_text )) self . has_errors = True # REVERSE COMPLEMENT nonpalindromic_oh = set ( self . overhang_input ) - set ( self . palindromic_oh ) nonpalindromic_oh_rc = { reverse_complement ( oh ) for oh in nonpalindromic_oh } rc_oh = nonpalindromic_oh & nonpalindromic_oh_rc if rc_oh : self . has_rc_error = True self . rc_error_text = ( \"Nonpalindromic overhang(s) with reverse complement: \" + \"; \" . join ( rc_oh ) ) print (( \"Incorrect set! \" + self . rc_error_text )) self . has_errors = True else : self . has_rc_error = False # SIMILAR OVERHANGS -- we do not consider it as a flaw self . similar_overhangs = self . find_similar_overhangs () # SET SIZE # Based on Pryor et al., PLoS ONE (2020): if self . overhang_length == 3 : # check overhang length on first one n = 10 if len ( self . overhang_input ) > n : self . set_size_text = ( \"Assembly fidelity significantly decreases when using \" + \"more than %d overhangs.\" % n ) # text used in report print ( \"Warning! \" + self . set_size_text ) elif self . overhang_length == 4 : n = 20 if len ( self . overhang_input ) > n : self . set_size_text = ( \"Assembly fidelity significantly decreases when using \" + \"more than %d overhangs.\" % n ) print ( \"Warning! \" + self . set_size_text ) else : self . set_size_text = \"\" # MISANNEALING self . evaluate_annealing () # also sets `has_warnings` # Tatapov plots: if make_plot : figwidth = len ( self . overhang_input ) print ( self . enzyme , \"Tatapov plot (37 Celsius, 1 hour):\" ) data = tatapov . annealing_data [ \"37C\" ][ enzyme_tatapov_lookup [ self . enzyme ]] subset = tatapov . data_subset ( data , self . overhang_input , add_reverse = True ) self . ax , _ = tatapov . plot_data ( subset , figwidth = figwidth , plot_color = \"Reds\" ) self . ax . figure . tight_layout () self . ax . plot () def evaluate_annealing ( self ): \"\"\"Evaluate weakly anneals, self-misanneals and misanneals between overhangs. Used in `inspect_overhangs()`. \"\"\" # Prepare data: data = tatapov . annealing_data [ \"37C\" ][ enzyme_tatapov_lookup [ self . enzyme ]] subset = tatapov . data_subset ( data , self . overhang_input , add_reverse = True ) # WEAK ANNEALS # See cutoff 400 in Pryor et al. Figure 2. self . weak_anneals_list = [ [ oh . overhang , oh . overhang_rc ] for oh in self . overhangs if subset [ oh . overhang ][ oh . overhang_rc ] < 400 ] # Convert to text self . weak_anneals = [ oh_pair [ 0 ] + \"/\" + oh_pair [ 1 ] for oh_pair in self . weak_anneals_list ] self . weak_anneals = \"; \" . join ( self . weak_anneals ) if not self . weak_anneals == \"\" : self . has_warnings = True # SELF-MISANNEALS self . self_misanneals_list = [ [ oh . overhang , oh . overhang_rc ] for oh in self . overhangs if subset [ oh . overhang ][ oh . overhang ] != 0 or subset [ oh . overhang_rc ][ oh . overhang_rc ] != 0 ] self . self_misanneals = [ oh_pair [ 0 ] + \"/\" + oh_pair [ 1 ] for oh_pair in self . self_misanneals_list ] self . self_misanneals = \"; \" . join ( self . self_misanneals ) if not self . self_misanneals == \"\" : self . has_warnings = True # MISANNEALS self . misanneals_list = [] for oh1 , oh2 in itertools . combinations ( self . overhangs , 2 ): # 10 below is a good cutoff for misannealing pairs if ( subset . loc [ [ oh1 . overhang , oh1 . overhang_rc ], [ oh2 . overhang , oh2 . overhang_rc ] ] > 10 ) . any ( axis = None ): # oh and reverse complement, in a list with its misannealing pair self . misanneals_list += [ [[ oh1 . overhang , oh1 . overhang_rc ], [ oh2 . overhang , oh2 . overhang_rc ]] ] # Create a text from the 4 overhangs, for the report: self . misanneals = [ misannealing_pair [ 0 ][ 0 ] + \"/\" + misannealing_pair [ 0 ][ 1 ] + \" ~ \" + misannealing_pair [ 1 ][ 0 ] + \"/\" + misannealing_pair [ 1 ][ 1 ] for misannealing_pair in self . misanneals_list ] self . misanneals = \"; \" . join ( self . misanneals ) if not self . misanneals == \"\" : self . has_warnings = True def find_similar_overhangs ( self , difference_threshold = None ): \"\"\"Find overhangs that differ in fewer nucleotides than the threshold. **Parameters** **difference_threshold** > Acceptable number of matching nucleotides in an overhang pair (`int`). Overhang pairs with fewer differences are marked as similar. Defaults to 0. \"\"\" if difference_threshold is None : difference_threshold = 0 similar_overhangs = \"\" for oh1 , oh2 in itertools . combinations ( self . overhangs , 2 ): if get_overhang_distance ( oh1 , oh2 ) < difference_threshold : similar_overhangs += ( oh1 . overhang + \"/\" + oh1 . overhang_rc + \" ~ \" + oh2 . overhang + \"/\" + oh2 . overhang_rc + \" ; \" ) if similar_overhangs == \"\" : similar_overhangs = ( \"No overhangs (including reverse complements) \" \"differ by fewer than %d nucleotides.\" % difference_threshold ) else : similar_overhangs = ( \"These overhang pairs (including reverse complements) have fewer than \" \" %d differences: \" % difference_threshold + similar_overhangs ) return similar_overhangs def find_perfect_subset ( self ): \"\"\"\"Find a better overhang set by removing bad overhang interactions. Bad interactions are weak anneals, self-misanneals and misanneals. \"\"\" self . inspect_overhangs ( make_plot = False ) # REMOVE WEAK oh_to_remove = [ oh for oh_pair in self . weak_anneals_list for oh in oh_pair ] self . subset = set ( self . overhang_input ) - set ( oh_to_remove ) # REMOVE SELF-MISANNEALING oh_to_remove = [ oh for oh_pair in self . self_misanneals_list for oh in oh_pair ] self . subset = set ( self . subset ) - set ( oh_to_remove ) # REMOVE MISANNEALING compatible_overhangs = [] misanneals_for_loop = [ pair [ 0 ] + pair [ 1 ] for pair in self . misanneals_list ] for oh1 , oh2 in itertools . combinations ( self . subset , 2 ): add_oh = True for pair in misanneals_for_loop : if oh1 in pair and oh2 in pair : add_oh = False break if add_oh : compatible_overhangs += [( oh1 , oh2 )] graph = networkx . Graph ( compatible_overhangs ) max_clique , clique_size = networkx . max_weight_clique ( graph , None ) self . subset = max_clique print ( \"Overhangs in subset: \" + str ( self . subset )) print ( \"Number of overhangs in subset: \" + str ( clique_size )) # Visualize subset: figwidth = len ( self . subset ) print ( self . enzyme , \"Tatapov plot (37 Celsius, 1 hour):\" ) data = tatapov . annealing_data [ \"37C\" ][ enzyme_tatapov_lookup [ self . enzyme ]] subset = tatapov . data_subset ( data , self . subset , add_reverse = True ) self . ax , _ = tatapov . plot_data ( subset , figwidth = figwidth , plot_color = \"Reds\" ) self . ax . figure . tight_layout () self . ax . plot ()","title":"Module overhang.OverhangSet"},{"location":"reference/overhang/OverhangSet/#variables","text":"enzyme_tatapov_lookup","title":"Variables"},{"location":"reference/overhang/OverhangSet/#classes","text":"","title":"Classes"},{"location":"reference/overhang/OverhangSet/#overhangset","text":"class OverhangSet ( overhangs , enzyme = 'Esp3I' , name = 'Unnamed set' ) Class for overhang sets . An overhang set is a collection of (mutually compatible) overhangs used for DNA assembly. Parameters overhangs A list of overhang strings ( list ). Example: [\"TAGG\", \"ATGG\", \"GACT\"] . enzyme Enzyme used for assembly ( str ). Example: \"Esp3I\" . name Name of the set ( str ). View Source class OverhangSet : \" \"\" Class for *overhang sets*. An overhang set is a collection of (mutually compatible) overhangs used for DNA assembly. **Parameters** **overhangs** > A list of overhang strings (`list`). Example: `[\" TAGG \", \" ATGG \", \" GACT \"]`. **enzyme** > Enzyme used for assembly (`str`). Example: `\" Esp3I \"`. **name** > Name of the set (`str`). \"\" \" def __init__ ( self , overhangs , enzyme = \"Esp3I\" , name = \"Unnamed set\" ) : self . overhangs = [ Overhang ( overhang ) for overhang in overhangs ] if len ( set ( overhangs )) != len ( overhangs ) : self . has_duplicates = True else : self . has_duplicates = False self . overhang_input = overhangs self . overhang_input_txt = \", \" . join ( self . overhang_input ) self . enzyme = enzyme self . name = name self . has_warnings = False # used during evaluation of set and reporting self . has_errors = False # used during evaluation of set and reporting self . overhang_length = len ( self . overhang_input [ 0 ] ) def inspect_overhangs ( self , make_plot = True ) : \" \"\" Inspect compatibility of overhangs and detect potential errors in the set. \"\" \" # DUPLICATES if self . has_duplicates : print ( \"Incorrect set! Duplicate overhangs\" ) self . has_errors = True # PALINDROMIC self . palindromic_oh = [] self . palindromic_oh += [ overhang . overhang for overhang in self . overhangs if overhang . is_palindromic ] if len ( self . palindromic_oh ) != 0 : self . palindromic_text = \"Palindromic overhang(s): \" + \"; \" . join ( self . palindromic_oh ) print (( \"Incorrect set! \" + self . palindromic_text )) self . has_errors = True # REVERSE COMPLEMENT nonpalindromic_oh = set ( self . overhang_input ) - set ( self . palindromic_oh ) nonpalindromic_oh_rc = { reverse_complement ( oh ) for oh in nonpalindromic_oh } rc_oh = nonpalindromic_oh & nonpalindromic_oh_rc if rc_oh : self . has_rc_error = True self . rc_error_text = ( \"Nonpalindromic overhang(s) with reverse complement: \" + \"; \" . join ( rc_oh ) ) print (( \"Incorrect set! \" + self . rc_error_text )) self . has_errors = True else : self . has_rc_error = False # SIMILAR OVERHANGS -- we do not consider it as a flaw self . similar_overhangs = self . find_similar_overhangs () # SET SIZE # Based on Pryor et al., PLoS ONE (2020): if self . overhang_length == 3 : # check overhang length on first one n = 10 if len ( self . overhang_input ) > n : self . set _size_text = ( \"Assembly fidelity significantly decreases when using \" + \"more than %d overhangs.\" % n ) # text used in report print ( \"Warning! \" + self . set _size_text ) elif self . overhang_length == 4 : n = 20 if len ( self . overhang_input ) > n : self . set _size_text = ( \"Assembly fidelity significantly decreases when using \" + \"more than %d overhangs.\" % n ) print ( \"Warning! \" + self . set _size_text ) else : self . set _size_text = \"\" # MISANNEALING self . evaluate_annealing () # also sets `has_warnings` # Tatapov plots: if make_plot : figwidth = len ( self . overhang_input ) print ( self . enzyme , \"Tatapov plot (37 Celsius, 1 hour):\" ) data = tatapov . annealing_data [ \"37C\" ][ enzyme_tatapov_lookup [ self . enzyme ]] subset = tatapov . data_subset ( data , self . overhang_input , add_reverse = True ) self . ax , _ = tatapov . plot_data ( subset , figwidth = figwidth , plot_color = \"Reds\" ) self . ax . figure . tight_layout () self . ax . plot () def evaluate_annealing ( self ) : \" \"\" Evaluate weakly anneals, self-misanneals and misanneals between overhangs. Used in `inspect_overhangs()`. \"\" \" # Prepare data: data = tatapov . annealing_data [ \"37C\" ][ enzyme_tatapov_lookup [ self . enzyme ]] subset = tatapov . data_subset ( data , self . overhang_input , add_reverse = True ) # WEAK ANNEALS # See cutoff 400 in Pryor et al. Figure 2. self . weak_anneals_list = [ [ oh . overhang , oh . overhang_rc ] for oh in self . overhangs if subset [ oh . overhang ][ oh . overhang_rc ] < 400 ] # Convert to text self . weak_anneals = [ oh_pair [ 0 ] + \"/\" + oh_pair [ 1 ] for oh_pair in self . weak_anneals_list ] self . weak_anneals = \"; \" . join ( self . weak_anneals ) if not self . weak_anneals == \"\" : self . has_warnings = True # SELF-MISANNEALS self . self_misanneals_list = [ [ oh . overhang , oh . overhang_rc ] for oh in self . overhangs if subset [ oh . overhang ][ oh . overhang ] != 0 or subset [ oh . overhang_rc ][ oh . overhang_rc ] != 0 ] self . self_misanneals = [ oh_pair [ 0 ] + \"/\" + oh_pair [ 1 ] for oh_pair in self . self_misanneals_list ] self . self_misanneals = \"; \" . join ( self . self_misanneals ) if not self . self_misanneals == \"\" : self . has_warnings = True # MISANNEALS self . misanneals_list = [] for oh1 , oh2 in itertools . combinations ( self . overhangs , 2 ) : # 10 below is a good cutoff for misannealing pairs if ( subset . loc [ [ oh1 . overhang , oh1 . overhang_rc ] , [ oh2 . overhang , oh2 . overhang_rc ] ] > 10 ). any ( axis = None ) : # oh and reverse complement, in a list with its misannealing pair self . misanneals_list += [ [[ oh1 . overhang , oh1 . overhang_rc ] , [ oh2 . overhang , oh2 . overhang_rc ]] ] # Create a text from the 4 overhangs, for the report: self . misanneals = [ misannealing_pair [ 0 ][ 0 ] + \"/\" + misannealing_pair [ 0 ][ 1 ] + \" ~ \" + misannealing_pair [ 1 ][ 0 ] + \"/\" + misannealing_pair [ 1 ][ 1 ] for misannealing_pair in self . misanneals_list ] self . misanneals = \"; \" . join ( self . misanneals ) if not self . misanneals == \"\" : self . has_warnings = True def find_similar_overhangs ( self , difference_threshold = None ) : \" \"\" Find overhangs that differ in fewer nucleotides than the threshold. **Parameters** **difference_threshold** > Acceptable number of matching nucleotides in an overhang pair (`int`). Overhang pairs with fewer differences are marked as similar. Defaults to 0. \"\" \" if difference_threshold is None : difference_threshold = 0 similar_overhangs = \"\" for oh1 , oh2 in itertools . combinations ( self . overhangs , 2 ) : if get_overhang_distance ( oh1 , oh2 ) < difference_threshold : similar_overhangs += ( oh1 . overhang + \"/\" + oh1 . overhang_rc + \" ~ \" + oh2 . overhang + \"/\" + oh2 . overhang_rc + \" ; \" ) if similar_overhangs == \"\" : similar_overhangs = ( \"No overhangs (including reverse complements) \" \"differ by fewer than %d nucleotides.\" % difference_threshold ) else : similar_overhangs = ( \"These overhang pairs (including reverse complements) have fewer than \" \"%d differences: \" % difference_threshold + similar_overhangs ) return similar_overhangs def find_perfect_subset ( self ) : \" \"\" \" Find a better overhang set by removing bad overhang interactions . Bad interactions are weak anneals , self - misanneals and misanneals . \" \"\" self.inspect_overhangs(make_plot=False) # REMOVE WEAK oh_to_remove = [oh for oh_pair in self.weak_anneals_list for oh in oh_pair] self.subset = set(self.overhang_input) - set(oh_to_remove) # REMOVE SELF-MISANNEALING oh_to_remove = [oh for oh_pair in self.self_misanneals_list for oh in oh_pair] self.subset = set(self.subset) - set(oh_to_remove) # REMOVE MISANNEALING compatible_overhangs = [] misanneals_for_loop = [pair[0] + pair[1] for pair in self.misanneals_list] for oh1, oh2 in itertools.combinations(self.subset, 2): add_oh = True for pair in misanneals_for_loop: if oh1 in pair and oh2 in pair: add_oh = False break if add_oh: compatible_overhangs += [(oh1, oh2)] graph = networkx.Graph(compatible_overhangs) max_clique, clique_size = networkx.max_weight_clique(graph, None) self.subset = max_clique print(\" Overhangs in subset : \" + str(self.subset)) print(\" Number of overhangs in subset : \" + str(clique_size)) # Visualize subset: figwidth = len(self.subset) print(self.enzyme, \" Tatapov plot ( 37 Celsius , 1 hour ) : \") data = tatapov.annealing_data[\" 37C \"][enzyme_tatapov_lookup[self.enzyme]] subset = tatapov.data_subset(data, self.subset, add_reverse=True) self.ax, _ = tatapov.plot_data(subset, figwidth=figwidth, plot_color=\" Reds \") self.ax.figure.tight_layout() self.ax.plot()","title":"OverhangSet"},{"location":"reference/overhang/OverhangSet/#methods","text":"","title":"Methods"},{"location":"reference/overhang/OverhangSet/#evaluate_annealing","text":"def evaluate_annealing ( self ) Evaluate weakly anneals, self-misanneals and misanneals between overhangs. Used in inspect_overhangs() . View Source def evaluate_annealing ( self ): \"\"\"Evaluate weakly anneals, self-misanneals and misanneals between overhangs. Used in `inspect_overhangs()`. \"\"\" # Prepare data: data = tatapov . annealing_data [ \"37C\" ][ enzyme_tatapov_lookup [ self . enzyme ]] subset = tatapov . data_subset ( data , self . overhang_input , add_reverse = True ) # WEAK ANNEALS # See cutoff 400 in Pryor et al. Figure 2. self . weak_anneals_list = [ [ oh . overhang , oh . overhang_rc ] for oh in self . overhangs if subset [ oh . overhang ][ oh . overhang_rc ] < 400 ] # Convert to text self . weak_anneals = [ oh_pair [ 0 ] + \"/\" + oh_pair [ 1 ] for oh_pair in self . weak_anneals_list ] self . weak_anneals = \"; \" . join ( self . weak_anneals ) if not self . weak_anneals == \"\" : self . has_warnings = True # SELF-MISANNEALS self . self_misanneals_list = [ [ oh . overhang , oh . overhang_rc ] for oh in self . overhangs if subset [ oh . overhang ][ oh . overhang ] != 0 or subset [ oh . overhang_rc ][ oh . overhang_rc ] != 0 ] self . self_misanneals = [ oh_pair [ 0 ] + \"/\" + oh_pair [ 1 ] for oh_pair in self . self_misanneals_list ] self . self_misanneals = \"; \" . join ( self . self_misanneals ) if not self . self_misanneals == \"\" : self . has_warnings = True # MISANNEALS self . misanneals_list = [] for oh1 , oh2 in itertools . combinations ( self . overhangs , 2 ): # 10 below is a good cutoff for misannealing pairs if ( subset . loc [ [ oh1 . overhang , oh1 . overhang_rc ], [ oh2 . overhang , oh2 . overhang_rc ] ] > 10 ) . any ( axis = None ): # oh and reverse complement, in a list with its misannealing pair self . misanneals_list += [ [[ oh1 . overhang , oh1 . overhang_rc ], [ oh2 . overhang , oh2 . overhang_rc ]] ] # Create a text from the 4 overhangs, for the report: self . misanneals = [ misannealing_pair [ 0 ][ 0 ] + \"/\" + misannealing_pair [ 0 ][ 1 ] + \" ~ \" + misannealing_pair [ 1 ][ 0 ] + \"/\" + misannealing_pair [ 1 ][ 1 ] for misannealing_pair in self . misanneals_list ] self . misanneals = \"; \" . join ( self . misanneals ) if not self . misanneals == \"\" : self . has_warnings = True","title":"evaluate_annealing"},{"location":"reference/overhang/OverhangSet/#find_perfect_subset","text":"def find_perfect_subset ( self ) \"Find a better overhang set by removing bad overhang interactions. Bad interactions are weak anneals, self-misanneals and misanneals. View Source def find_perfect_subset ( self ): \"\"\"\"Find a better overhang set by removing bad overhang interactions. Bad interactions are weak anneals, self-misanneals and misanneals. \"\"\" self . inspect_overhangs ( make_plot = False ) # REMOVE WEAK oh_to_remove = [ oh for oh_pair in self . weak_anneals_list for oh in oh_pair ] self . subset = set ( self . overhang_input ) - set ( oh_to_remove ) # REMOVE SELF-MISANNEALING oh_to_remove = [ oh for oh_pair in self . self_misanneals_list for oh in oh_pair ] self . subset = set ( self . subset ) - set ( oh_to_remove ) # REMOVE MISANNEALING compatible_overhangs = [] misanneals_for_loop = [ pair [ 0 ] + pair [ 1 ] for pair in self . misanneals_list ] for oh1 , oh2 in itertools . combinations ( self . subset , 2 ): add_oh = True for pair in misanneals_for_loop : if oh1 in pair and oh2 in pair : add_oh = False break if add_oh : compatible_overhangs += [( oh1 , oh2 )] graph = networkx . Graph ( compatible_overhangs ) max_clique , clique_size = networkx . max_weight_clique ( graph , None ) self . subset = max_clique print ( \"Overhangs in subset: \" + str ( self . subset )) print ( \"Number of overhangs in subset: \" + str ( clique_size )) # Visualize subset: figwidth = len ( self . subset ) print ( self . enzyme , \"Tatapov plot (37 Celsius, 1 hour):\" ) data = tatapov . annealing_data [ \"37C\" ][ enzyme_tatapov_lookup [ self . enzyme ]] subset = tatapov . data_subset ( data , self . subset , add_reverse = True ) self . ax , _ = tatapov . plot_data ( subset , figwidth = figwidth , plot_color = \"Reds\" ) self . ax . figure . tight_layout () self . ax . plot ()","title":"find_perfect_subset"},{"location":"reference/overhang/OverhangSet/#find_similar_overhangs","text":"def find_similar_overhangs ( self , difference_threshold = None ) Find overhangs that differ in fewer nucleotides than the threshold. Parameters difference_threshold Acceptable number of matching nucleotides in an overhang pair ( int ). Overhang pairs with fewer differences are marked as similar. Defaults to 0. View Source def find_similar_overhangs ( self , difference_threshold = None ) : \" \"\" Find overhangs that differ in fewer nucleotides than the threshold. **Parameters** **difference_threshold** > Acceptable number of matching nucleotides in an overhang pair (`int`). Overhang pairs with fewer differences are marked as similar. Defaults to 0. \"\" \" if difference_threshold is None : difference_threshold = 0 similar_overhangs = \"\" for oh1 , oh2 in itertools . combinations ( self . overhangs , 2 ) : if get_overhang_distance ( oh1 , oh2 ) < difference_threshold : similar_overhangs += ( oh1 . overhang + \"/\" + oh1 . overhang_rc + \" ~ \" + oh2 . overhang + \"/\" + oh2 . overhang_rc + \" ; \" ) if similar_overhangs == \"\" : similar_overhangs = ( \"No overhangs (including reverse complements) \" \"differ by fewer than %d nucleotides.\" % difference_threshold ) else : similar_overhangs = ( \"These overhang pairs (including reverse complements) have fewer than \" \"%d differences: \" % difference_threshold + similar_overhangs ) return similar_overhangs","title":"find_similar_overhangs"},{"location":"reference/overhang/OverhangSet/#inspect_overhangs","text":"def inspect_overhangs ( self , make_plot = True ) Inspect compatibility of overhangs and detect potential errors in the set. View Source def inspect_overhangs ( self , make_plot = True ) : \" \"\" Inspect compatibility of overhangs and detect potential errors in the set. \"\" \" # DUPLICATES if self . has_duplicates : print ( \"Incorrect set! Duplicate overhangs\" ) self . has_errors = True # PALINDROMIC self . palindromic_oh = [] self . palindromic_oh += [ overhang . overhang for overhang in self . overhangs if overhang . is_palindromic ] if len ( self . palindromic_oh ) != 0 : self . palindromic_text = \"Palindromic overhang(s): \" + \"; \" . join ( self . palindromic_oh ) print (( \"Incorrect set! \" + self . palindromic_text )) self . has_errors = True # REVERSE COMPLEMENT nonpalindromic_oh = set ( self . overhang_input ) - set ( self . palindromic_oh ) nonpalindromic_oh_rc = { reverse_complement ( oh ) for oh in nonpalindromic_oh } rc_oh = nonpalindromic_oh & nonpalindromic_oh_rc if rc_oh : self . has_rc_error = True self . rc_error_text = ( \"Nonpalindromic overhang(s) with reverse complement: \" + \"; \" . join ( rc_oh ) ) print (( \"Incorrect set! \" + self . rc_error_text )) self . has_errors = True else : self . has_rc_error = False # SIMILAR OVERHANGS -- we do not consider it as a flaw self . similar_overhangs = self . find_similar_overhangs () # SET SIZE # Based on Pryor et al., PLoS ONE (2020): if self . overhang_length == 3 : # check overhang length on first one n = 10 if len ( self . overhang_input ) > n : self . set _size_text = ( \"Assembly fidelity significantly decreases when using \" + \"more than %d overhangs.\" % n ) # text used in report print ( \"Warning! \" + self . set _size_text ) elif self . overhang_length == 4 : n = 20 if len ( self . overhang_input ) > n : self . set _size_text = ( \"Assembly fidelity significantly decreases when using \" + \"more than %d overhangs.\" % n ) print ( \"Warning! \" + self . set _size_text ) else : self . set _size_text = \"\" # MISANNEALING self . evaluate_annealing () # also sets `has_warnings` # Tatapov plots: if make_plot : figwidth = len ( self . overhang_input ) print ( self . enzyme , \"Tatapov plot (37 Celsius, 1 hour):\" ) data = tatapov . annealing_data [ \"37C\" ][ enzyme_tatapov_lookup [ self . enzyme ]] subset = tatapov . data_subset ( data , self . overhang_input , add_reverse = True ) self . ax , _ = tatapov . plot_data ( subset , figwidth = figwidth , plot_color = \"Reds\" ) self . ax . figure . tight_layout () self . ax . plot ()","title":"inspect_overhangs"},{"location":"reference/overhang/reports/","text":"Module overhang.reports View Source import os # import matplotlib.pyplot as plt # import pandas import tatapov from pdf_reports import ( add_css_class , dataframe_to_html , pug_to_html , style_table_rows , write_report , ) import pdf_reports.tools as pdf_tools from .tools import subset_data_for_overhang , plot_data , enzyme_tatapov_lookup from .version import __version__ THIS_PATH = os . path . dirname ( os . path . realpath ( __file__ )) ASSETS_PATH = os . path . join ( THIS_PATH , \"report_assets\" ) REPORT_TEMPLATE = os . path . join ( ASSETS_PATH , \"overhang_report.pug\" ) SET_REPORT_TEMPLATE = os . path . join ( ASSETS_PATH , \"overhangset_report.pug\" ) STYLESHEET = os . path . join ( ASSETS_PATH , \"report_style.css\" ) def end_pug_to_html ( template , ** context ): defaults = { \"sidebar_text\" : \"EGF's compendium of overhangs (version %s )\" % ( __version__ ), } for k in defaults : if k not in context : context [ k ] = defaults [ k ] return pug_to_html ( template , ** context ) def write_pdf_report ( target , overhangs , enzyme = \"Esp3I\" ): \"\"\"Write an overhang compendium. **Parameters** **target** > Path for PDF file (`str`). **overhangs** > List of `Overhang` instances (`list`). **enzyme** > Enzyme used for assembly (`str`). Options: `\"BsaI\"`, `\"BsmBI\"`, `\"Esp3I\"` or `\"BbsI\"`. \"\"\" # Prepare data for the plots: data = tatapov . annealing_data [ \"37C\" ][ enzyme_tatapov_lookup [ enzyme ]] for overhang in overhangs : overhang . is_usable = overhang . is_good () overhang . gc_content_percent = int ( overhang . gc_content * 100 ) # to display as % if overhang . gc_content < 0.25 or 0.75 < overhang . gc_content : # none or all GC overhang . has_extreme_gc = True else : overhang . has_extreme_gc = False # Prepare the plotting data: subset_data = subset_data_for_overhang ( data , overhang ) # Make the plot: overhang . tatapov_figure , _ = plot_data ( subset_data ) # Convert the plot for PDF: overhang . figure_data = pdf_tools . figure_data ( overhang . tatapov_figure , fmt = \"svg\" ) html = end_pug_to_html ( REPORT_TEMPLATE , overhangs = overhangs , number_of_overhangs = len ( overhangs ), enzyme = enzyme , ) write_report ( html , target , extra_stylesheets = ( STYLESHEET ,)) def write_overhangset_report ( target , overhangset ): \"\"\"Write a report on an overhang set. **Parameters** **target** > Path for PDF file (`str`). **overhangset** > An `OverhangSet` instance. \"\"\" # Prepare data for the plots: data = tatapov . annealing_data [ \"37C\" ][ enzyme_tatapov_lookup [ overhangset . enzyme ]] overhangset . inspect_overhangs () height = overhangset . ax . figure . get_size_inches ()[ 1 ] if height > 10 : height = 10 # to fit on the page overhangset . figure_data = pdf_tools . figure_data ( overhangset . ax , fmt = \"svg\" , size = [ 7 , height ] ) for overhang in overhangset . overhangs : overhang . is_usable = overhang . is_good () overhang . gc_content_percent = int ( overhang . gc_content * 100 ) # to display as % if overhang . gc_content < 0.25 or 0.75 < overhang . gc_content : # none or all GC overhang . has_extreme_gc = True else : overhang . has_extreme_gc = False # Prepare the plotting data: subset_data = subset_data_for_overhang ( data , overhang ) # Make the plot: overhang . tatapov_figure , _ = plot_data ( subset_data ) # Convert the plot for PDF: overhang . figure_data = pdf_tools . figure_data ( overhang . tatapov_figure , fmt = \"svg\" ) html = end_pug_to_html ( SET_REPORT_TEMPLATE , overhangset = overhangset , number_of_overhangs = len ( overhangset . overhangs ), # Report overhang pairs with 1 (less than 2) difference: similar_overhangs = overhangset . find_similar_overhangs ( difference_threshold = 2 ), ) write_report ( html , target , extra_stylesheets = ( STYLESHEET ,)) Variables ASSETS_PATH REPORT_TEMPLATE SET_REPORT_TEMPLATE STYLESHEET THIS_PATH enzyme_tatapov_lookup Functions end_pug_to_html def end_pug_to_html ( template , ** context ) View Source def end_pug_to_html ( template , ** context ) : defaults = { \"sidebar_text\" : \"EGF's compendium of overhangs (version %s)\" % ( __version__ ), } for k in defaults : if k not in context : context [ k ] = defaults [ k ] return pug_to_html ( template , ** context ) write_overhangset_report def write_overhangset_report ( target , overhangset ) Write a report on an overhang set. Parameters target Path for PDF file ( str ). overhangset An OverhangSet instance. View Source def write_overhangset_report ( target , overhangset ) : \" \"\" Write a report on an overhang set. **Parameters** **target** > Path for PDF file (`str`). **overhangset** > An `OverhangSet` instance. \"\" \" # Prepare data for the plots: data = tatapov . annealing_data [ \"37C\" ][ enzyme_tatapov_lookup [ overhangset . enzyme ]] overhangset . inspect_overhangs () height = overhangset . ax . figure . get_size_inches () [ 1 ] if height > 10 : height = 10 # to fit on the page overhangset . figure_data = pdf_tools . figure_data ( overhangset . ax , fmt = \"svg\" , size = [ 7 , height ] ) for overhang in overhangset . overhangs : overhang . is_usable = overhang . is_good () overhang . gc_content_percent = int ( overhang . gc_content * 100 ) # to display as % if overhang . gc_content < 0.25 or 0.75 < overhang . gc_content : # none or all GC overhang . has_extreme_gc = True else : overhang . has_extreme_gc = False # Prepare the plotting data: subset_data = subset_data_for_overhang ( data , overhang ) # Make the plot: overhang . tatapov_figure , _ = plot_data ( subset_data ) # Convert the plot for PDF: overhang . figure_data = pdf_tools . figure_data ( overhang . tatapov_figure , fmt = \"svg\" ) html = end_pug_to_html ( SET _REPORT_TEMPLATE , overhangset = overhangset , number_of_overhangs = len ( overhangset . overhangs ), # Report overhang pairs with 1 (less than 2) difference: similar_overhangs = overhangset . find_similar_overhangs ( difference_threshold = 2 ), ) write_report ( html , target , extra_stylesheets = ( STYLESHEET ,)) write_pdf_report def write_pdf_report ( target , overhangs , enzyme = 'Esp3I' ) Write an overhang compendium. Parameters target Path for PDF file ( str ). overhangs List of Overhang instances ( list ). enzyme Enzyme used for assembly ( str ). Options: \"BsaI\" , \"BsmBI\" , \"Esp3I\" or \"BbsI\" . View Source def write_pdf_report ( target , overhangs , enzyme = \"Esp3I\" ) : \" \"\" Write an overhang compendium. **Parameters** **target** > Path for PDF file (`str`). **overhangs** > List of `Overhang` instances (`list`). **enzyme** > Enzyme used for assembly (`str`). Options: `\" BsaI \"`, `\" BsmBI \"`, `\" Esp3I \"` or `\" BbsI \"`. \"\" \" # Prepare data for the plots: data = tatapov . annealing_data [ \"37C\" ][ enzyme_tatapov_lookup [ enzyme ]] for overhang in overhangs : overhang . is_usable = overhang . is_good () overhang . gc_content_percent = int ( overhang . gc_content * 100 ) # to display as % if overhang . gc_content < 0.25 or 0.75 < overhang . gc_content : # none or all GC overhang . has_extreme_gc = True else : overhang . has_extreme_gc = False # Prepare the plotting data: subset_data = subset_data_for_overhang ( data , overhang ) # Make the plot: overhang . tatapov_figure , _ = plot_data ( subset_data ) # Convert the plot for PDF: overhang . figure_data = pdf_tools . figure_data ( overhang . tatapov_figure , fmt = \"svg\" ) html = end_pug_to_html ( REPORT_TEMPLATE , overhangs = overhangs , number_of_overhangs = len ( overhangs ), enzyme = enzyme , ) write_report ( html , target , extra_stylesheets = ( STYLESHEET ,))","title":"Reports"},{"location":"reference/overhang/reports/#module-overhangreports","text":"View Source import os # import matplotlib.pyplot as plt # import pandas import tatapov from pdf_reports import ( add_css_class , dataframe_to_html , pug_to_html , style_table_rows , write_report , ) import pdf_reports.tools as pdf_tools from .tools import subset_data_for_overhang , plot_data , enzyme_tatapov_lookup from .version import __version__ THIS_PATH = os . path . dirname ( os . path . realpath ( __file__ )) ASSETS_PATH = os . path . join ( THIS_PATH , \"report_assets\" ) REPORT_TEMPLATE = os . path . join ( ASSETS_PATH , \"overhang_report.pug\" ) SET_REPORT_TEMPLATE = os . path . join ( ASSETS_PATH , \"overhangset_report.pug\" ) STYLESHEET = os . path . join ( ASSETS_PATH , \"report_style.css\" ) def end_pug_to_html ( template , ** context ): defaults = { \"sidebar_text\" : \"EGF's compendium of overhangs (version %s )\" % ( __version__ ), } for k in defaults : if k not in context : context [ k ] = defaults [ k ] return pug_to_html ( template , ** context ) def write_pdf_report ( target , overhangs , enzyme = \"Esp3I\" ): \"\"\"Write an overhang compendium. **Parameters** **target** > Path for PDF file (`str`). **overhangs** > List of `Overhang` instances (`list`). **enzyme** > Enzyme used for assembly (`str`). Options: `\"BsaI\"`, `\"BsmBI\"`, `\"Esp3I\"` or `\"BbsI\"`. \"\"\" # Prepare data for the plots: data = tatapov . annealing_data [ \"37C\" ][ enzyme_tatapov_lookup [ enzyme ]] for overhang in overhangs : overhang . is_usable = overhang . is_good () overhang . gc_content_percent = int ( overhang . gc_content * 100 ) # to display as % if overhang . gc_content < 0.25 or 0.75 < overhang . gc_content : # none or all GC overhang . has_extreme_gc = True else : overhang . has_extreme_gc = False # Prepare the plotting data: subset_data = subset_data_for_overhang ( data , overhang ) # Make the plot: overhang . tatapov_figure , _ = plot_data ( subset_data ) # Convert the plot for PDF: overhang . figure_data = pdf_tools . figure_data ( overhang . tatapov_figure , fmt = \"svg\" ) html = end_pug_to_html ( REPORT_TEMPLATE , overhangs = overhangs , number_of_overhangs = len ( overhangs ), enzyme = enzyme , ) write_report ( html , target , extra_stylesheets = ( STYLESHEET ,)) def write_overhangset_report ( target , overhangset ): \"\"\"Write a report on an overhang set. **Parameters** **target** > Path for PDF file (`str`). **overhangset** > An `OverhangSet` instance. \"\"\" # Prepare data for the plots: data = tatapov . annealing_data [ \"37C\" ][ enzyme_tatapov_lookup [ overhangset . enzyme ]] overhangset . inspect_overhangs () height = overhangset . ax . figure . get_size_inches ()[ 1 ] if height > 10 : height = 10 # to fit on the page overhangset . figure_data = pdf_tools . figure_data ( overhangset . ax , fmt = \"svg\" , size = [ 7 , height ] ) for overhang in overhangset . overhangs : overhang . is_usable = overhang . is_good () overhang . gc_content_percent = int ( overhang . gc_content * 100 ) # to display as % if overhang . gc_content < 0.25 or 0.75 < overhang . gc_content : # none or all GC overhang . has_extreme_gc = True else : overhang . has_extreme_gc = False # Prepare the plotting data: subset_data = subset_data_for_overhang ( data , overhang ) # Make the plot: overhang . tatapov_figure , _ = plot_data ( subset_data ) # Convert the plot for PDF: overhang . figure_data = pdf_tools . figure_data ( overhang . tatapov_figure , fmt = \"svg\" ) html = end_pug_to_html ( SET_REPORT_TEMPLATE , overhangset = overhangset , number_of_overhangs = len ( overhangset . overhangs ), # Report overhang pairs with 1 (less than 2) difference: similar_overhangs = overhangset . find_similar_overhangs ( difference_threshold = 2 ), ) write_report ( html , target , extra_stylesheets = ( STYLESHEET ,))","title":"Module overhang.reports"},{"location":"reference/overhang/reports/#variables","text":"ASSETS_PATH REPORT_TEMPLATE SET_REPORT_TEMPLATE STYLESHEET THIS_PATH enzyme_tatapov_lookup","title":"Variables"},{"location":"reference/overhang/reports/#functions","text":"","title":"Functions"},{"location":"reference/overhang/reports/#end_pug_to_html","text":"def end_pug_to_html ( template , ** context ) View Source def end_pug_to_html ( template , ** context ) : defaults = { \"sidebar_text\" : \"EGF's compendium of overhangs (version %s)\" % ( __version__ ), } for k in defaults : if k not in context : context [ k ] = defaults [ k ] return pug_to_html ( template , ** context )","title":"end_pug_to_html"},{"location":"reference/overhang/reports/#write_overhangset_report","text":"def write_overhangset_report ( target , overhangset ) Write a report on an overhang set. Parameters target Path for PDF file ( str ). overhangset An OverhangSet instance. View Source def write_overhangset_report ( target , overhangset ) : \" \"\" Write a report on an overhang set. **Parameters** **target** > Path for PDF file (`str`). **overhangset** > An `OverhangSet` instance. \"\" \" # Prepare data for the plots: data = tatapov . annealing_data [ \"37C\" ][ enzyme_tatapov_lookup [ overhangset . enzyme ]] overhangset . inspect_overhangs () height = overhangset . ax . figure . get_size_inches () [ 1 ] if height > 10 : height = 10 # to fit on the page overhangset . figure_data = pdf_tools . figure_data ( overhangset . ax , fmt = \"svg\" , size = [ 7 , height ] ) for overhang in overhangset . overhangs : overhang . is_usable = overhang . is_good () overhang . gc_content_percent = int ( overhang . gc_content * 100 ) # to display as % if overhang . gc_content < 0.25 or 0.75 < overhang . gc_content : # none or all GC overhang . has_extreme_gc = True else : overhang . has_extreme_gc = False # Prepare the plotting data: subset_data = subset_data_for_overhang ( data , overhang ) # Make the plot: overhang . tatapov_figure , _ = plot_data ( subset_data ) # Convert the plot for PDF: overhang . figure_data = pdf_tools . figure_data ( overhang . tatapov_figure , fmt = \"svg\" ) html = end_pug_to_html ( SET _REPORT_TEMPLATE , overhangset = overhangset , number_of_overhangs = len ( overhangset . overhangs ), # Report overhang pairs with 1 (less than 2) difference: similar_overhangs = overhangset . find_similar_overhangs ( difference_threshold = 2 ), ) write_report ( html , target , extra_stylesheets = ( STYLESHEET ,))","title":"write_overhangset_report"},{"location":"reference/overhang/reports/#write_pdf_report","text":"def write_pdf_report ( target , overhangs , enzyme = 'Esp3I' ) Write an overhang compendium. Parameters target Path for PDF file ( str ). overhangs List of Overhang instances ( list ). enzyme Enzyme used for assembly ( str ). Options: \"BsaI\" , \"BsmBI\" , \"Esp3I\" or \"BbsI\" . View Source def write_pdf_report ( target , overhangs , enzyme = \"Esp3I\" ) : \" \"\" Write an overhang compendium. **Parameters** **target** > Path for PDF file (`str`). **overhangs** > List of `Overhang` instances (`list`). **enzyme** > Enzyme used for assembly (`str`). Options: `\" BsaI \"`, `\" BsmBI \"`, `\" Esp3I \"` or `\" BbsI \"`. \"\" \" # Prepare data for the plots: data = tatapov . annealing_data [ \"37C\" ][ enzyme_tatapov_lookup [ enzyme ]] for overhang in overhangs : overhang . is_usable = overhang . is_good () overhang . gc_content_percent = int ( overhang . gc_content * 100 ) # to display as % if overhang . gc_content < 0.25 or 0.75 < overhang . gc_content : # none or all GC overhang . has_extreme_gc = True else : overhang . has_extreme_gc = False # Prepare the plotting data: subset_data = subset_data_for_overhang ( data , overhang ) # Make the plot: overhang . tatapov_figure , _ = plot_data ( subset_data ) # Convert the plot for PDF: overhang . figure_data = pdf_tools . figure_data ( overhang . tatapov_figure , fmt = \"svg\" ) html = end_pug_to_html ( REPORT_TEMPLATE , overhangs = overhangs , number_of_overhangs = len ( overhangs ), enzyme = enzyme , ) write_report ( html , target , extra_stylesheets = ( STYLESHEET ,))","title":"write_pdf_report"},{"location":"reference/overhang/tools/","text":"Module overhang.tools View Source import itertools import tatapov import numpy as np import matplotlib.pyplot as plt complements = { \"A\" : \"T\" , \"T\" : \"A\" , \"C\" : \"G\" , \"G\" : \"C\" } enzyme_tatapov_lookup = { \"BsaI\" : \"2020_01h_BsaI\" , \"BsmBI\" : \"2020_01h_BsmBI\" , \"Esp3I\" : \"2020_01h_Esp3I\" , \"BbsI\" : \"2020_01h_BbsI\" , } def reverse_complement ( sequence ): \"\"\"Return the reverse complement of a DNA sequence. For instance `reverse_complement(\"ATGC\")` returns `\"GCAT\"`. **Parameters** **sequence** > An ATGC string (`str`). \"\"\" return \"\" . join ([ complements [ c ] for c in sequence [:: - 1 ]]) def gc_content ( sequence ): \"\"\"Return the proportion of G and C in the sequence (between 0 and 1). This function is equivalent to `goldenhinges.biotools.gc_content()`. **Parameters** **sequence* > An ATGC string (`str`). \"\"\" return 1.0 * len ([ c for c in sequence if c in \"GC\" ]) / len ( sequence ) def order_overhangs ( seq ): \"\"\"Create an overhang's reverse complement, and return them in order. Overhangs are ordered by the letters, e.g. AATA < TATT. **Parameters** **seq** > ACGT sequence (`str`).\"\"\" sorted_overhangs = [ seq , reverse_complement ( seq )] sorted_overhangs . sort () return sorted_overhangs [ 0 ], sorted_overhangs [ 1 ] def generate_overhang_pairs ( overhang_length = 4 ): \"\"\"Generate all overhang pairs of given length. **Parameters** **overhang_length** > Length of overhangs (`int`). \"\"\" raw_overhangs = [ \"\" . join ( overhang ) for overhang in itertools . product ( * overhang_length * ( \"ACGT\" ,)) ] # adapted from goldenhinges overhang_pairs = [] # for each overhang and its complement for overhang in raw_overhangs : overhang_pairs += [ frozenset ([ overhang , reverse_complement ( overhang )])] overhang_pairs = set ( overhang_pairs ) # remove duplicate pairs return overhang_pairs def subset_data_for_overhang ( dataframe , overhang , horizontal = True , filter = True ): \"\"\"Subset tatapov dataframe for given overhang. **Parameters** **dataframe** > Tatapov dataset, for example `tatapov.annealing_data[\"25C\"][\"01h\"]` **overhang** > Overhang class instance (`Overhang`) **horizontal** > Orientation of returned dataframe (`bool`). **filter** > If True, keep only columns (if horizontal=True) or rows (if horizontal=False) with nonzero values (`bool`). \"\"\" overhangs = [ overhang . overhang , overhang . overhang_rc ] if horizontal : subset_data = dataframe . loc [ overhangs ] if filter : subset_data = subset_data . loc [:, subset_data . sum ( axis = 0 ) != 0 ] return subset_data else : # vertical subset_data = dataframe [ overhangs ] if filter : subset_data = subset_data . loc [ subset_data . sum ( axis = 1 ) != 0 , :] return subset_data def plot_data ( df , ax = None , colorbar = True , figwidth = 8 , plot_color = \"Reds\" ): \"\"\"Plot a (restricted) tatapov dataframe. **Parameters** **df** > One of the data sheets provided by tatapov, e.g. ``annealing_data[\"37C\"][\"01h\"]``. Or a restriction using ``data_subset``. **ax** > A Matplotlib ax. If none is provided, one will be created and returned at the end. **colorbar** > If True, the figure will have a colorbar. **figwidth** > Custom width of the figure. **plot_color** > A Matplotlib colormap name. \"\"\" # Adapted from tatapov.plot_data() if ax is None : _ , ax = plt . subplots ( 1 , figsize = ( figwidth , 1.5 )) values = np . log10 ( np . maximum ( 0.5 , df . values [:: - 1 ])) im = ax . imshow ( values , cmap = plot_color ) if colorbar : ax . figure . colorbar ( im , label = \"log10( occurrences )\" ) xtick_labels = df . columns ax . set_xticks ( range ( len ( xtick_labels ))) ax . set_xticklabels ( xtick_labels , rotation = 90 ) ax . xaxis . tick_top () ax . set_xlim ( right = len ( xtick_labels ) - 0.5 ) ytick_labels = df . index [:: - 1 ] ax . set_yticks ( range ( len ( ytick_labels ))) ax . set_yticklabels ( ytick_labels ) ax . set_ylim ( - 0.5 , len ( ytick_labels ) - 0.5 ) plt . close () return ax , im def filter_overhangs ( overhangs , enzyme = \"Esp3I\" ): \"\"\"Filter overhangs using the Tatapov package. Filter out the weakly annealing and self-misannealing overhangs. **Parameters** **overhangs** > List of Overhang instances (`list`). **enzyme** > Enzyme used with the overhangs (`str`). See `overhang.tools.enzyme_tatapov_lookup` for options. \"\"\" data = tatapov . annealing_data [ \"37C\" ][ enzyme_tatapov_lookup [ enzyme ]] overhang_input = [ overhang . overhang for overhang in overhangs ] subset = tatapov . data_subset ( data , overhang_input , add_reverse = True ) # WEAK ANNEALS # See cutoff 400 in Pryor et al. Figure 2. strong_overhangs = [] for overhang in overhangs : if subset [ overhang . overhang ][ overhang . overhang_rc ] >= 400 : strong_overhangs += [ overhang ] # SELF-MISANNEALS # Use 0 as cutoff: good_overhangs = [] for overhang in strong_overhangs : if ( subset [ overhang . overhang ][ overhang . overhang ] == 0 and subset [ overhang . overhang_rc ][ overhang . overhang_rc ] == 0 ): good_overhangs += [ overhang ] return good_overhangs Variables complements enzyme_tatapov_lookup Functions filter_overhangs def filter_overhangs ( overhangs , enzyme = 'Esp3I' ) Filter overhangs using the Tatapov package. Filter out the weakly annealing and self-misannealing overhangs. Parameters overhangs List of Overhang instances ( list ). enzyme Enzyme used with the overhangs ( str ). See overhang.tools.enzyme_tatapov_lookup for options. View Source def filter_overhangs ( overhangs , enzyme = \"Esp3I\" ): \"\"\"Filter overhangs using the Tatapov package. Filter out the weakly annealing and self-misannealing overhangs. **Parameters** **overhangs** > List of Overhang instances (`list`). **enzyme** > Enzyme used with the overhangs (`str`). See `overhang.tools.enzyme_tatapov_lookup` for options. \"\"\" data = tatapov . annealing_data [ \"37C\" ][ enzyme_tatapov_lookup [ enzyme ]] overhang_input = [ overhang . overhang for overhang in overhangs ] subset = tatapov . data_subset ( data , overhang_input , add_reverse = True ) # WEAK ANNEALS # See cutoff 400 in Pryor et al. Figure 2. strong_overhangs = [] for overhang in overhangs : if subset [ overhang . overhang ][ overhang . overhang_rc ] >= 400 : strong_overhangs += [ overhang ] # SELF-MISANNEALS # Use 0 as cutoff: good_overhangs = [] for overhang in strong_overhangs : if ( subset [ overhang . overhang ][ overhang . overhang ] == 0 and subset [ overhang . overhang_rc ][ overhang . overhang_rc ] == 0 ): good_overhangs += [ overhang ] return good_overhangs gc_content def gc_content ( sequence ) Return the proportion of G and C in the sequence (between 0 and 1). This function is equivalent to goldenhinges.biotools.gc_content() . Parameters * sequence An ATGC string ( str ). View Source def gc_content ( sequence ) : \" \"\" Return the proportion of G and C in the sequence (between 0 and 1). This function is equivalent to `goldenhinges.biotools.gc_content()`. **Parameters** **sequence* > An ATGC string (`str`). \"\" \" return 1.0 * len ( [ c for c in sequence if c in \"GC\" ] ) / len ( sequence ) generate_overhang_pairs def generate_overhang_pairs ( overhang_length = 4 ) Generate all overhang pairs of given length. Parameters overhang_length Length of overhangs ( int ). View Source def generate_overhang_pairs ( overhang_length = 4 ) : \" \"\" Generate all overhang pairs of given length. **Parameters** **overhang_length** > Length of overhangs (`int`). \"\" \" raw_overhangs = [ \"\" . join ( overhang ) for overhang in itertools . product ( * overhang_length * ( \"ACGT\" ,)) ] # adapted from goldenhinges overhang_pairs = [] # for each overhang and its complement for overhang in raw_overhangs : overhang_pairs += [ frozenset ( [ overhang , reverse_complement ( overhang ) ] ) ] overhang_pairs = set ( overhang_pairs ) # remove duplicate pairs return overhang_pairs order_overhangs def order_overhangs ( seq ) Create an overhang's reverse complement, and return them in order. Overhangs are ordered by the letters, e.g. AATA < TATT. Parameters seq ACGT sequence ( str ). View Source def order_overhangs ( seq ) : \" \"\" Create an overhang's reverse complement, and return them in order. Overhangs are ordered by the letters, e.g. AATA < TATT. **Parameters** **seq** > ACGT sequence (`str`). \"\" \" sorted_overhangs = [ seq , reverse_complement ( seq ) ] sorted_overhangs . sort () return sorted_overhangs [ 0 ] , sorted_overhangs [ 1 ] plot_data def plot_data ( df , ax = None , colorbar = True , figwidth = 8 , plot_color = 'Reds' ) Plot a (restricted) tatapov dataframe. Parameters df One of the data sheets provided by tatapov, e.g. annealing_data[\"37C\"][\"01h\"] . Or a restriction using data_subset . ax A Matplotlib ax. If none is provided, one will be created and returned at the end. colorbar If True, the figure will have a colorbar. figwidth Custom width of the figure. plot_color A Matplotlib colormap name. View Source def plot_data ( df , ax = None , colorbar = True , figwidth = 8 , plot_color= \"Reds\" ) : \"\"\"Plot a (restricted) tatapov dataframe. **Parameters** **df** > One of the data sheets provided by tatapov, e.g. ``annealing_data[\" 37 C \"][\" 01 h \"]``. Or a restriction using ``data_subset``. **ax** > A Matplotlib ax. If none is provided, one will be created and returned at the end. **colorbar** > If True, the figure will have a colorbar. **figwidth** > Custom width of the figure. **plot_color** > A Matplotlib colormap name. \"\"\" # Adapted from tatapov . plot_data () if ax is None : _ , ax = plt . subplots ( 1 , figsize= ( figwidth , 1.5 )) values = np . log10 ( np . maximum ( 0.5 , df . values [ ::- 1 ])) im = ax . imshow ( values , cmap = plot_color ) if colorbar : ax . figure . colorbar ( im , label= \"log10( occurrences )\" ) xtick_labels = df . columns ax . set_xticks ( range ( len ( xtick_labels ))) ax . set_xticklabels ( xtick_labels , rotation = 90 ) ax . xaxis . tick_top () ax . set_xlim ( right = len ( xtick_labels ) - 0.5 ) ytick_labels = df . index [ ::- 1 ] ax . set_yticks ( range ( len ( ytick_labels ))) ax . set_yticklabels ( ytick_labels ) ax . set_ylim ( - 0.5 , len ( ytick_labels ) - 0.5 ) plt . close () return ax , im reverse_complement def reverse_complement ( sequence ) Return the reverse complement of a DNA sequence. For instance reverse_complement(\"ATGC\") returns \"GCAT\" . Parameters sequence An ATGC string ( str ). View Source def reverse_complement ( sequence ) : \"\"\"Return the reverse complement of a DNA sequence. For instance `reverse_complement(\" ATGC \")` returns `\" GCAT \"`. **Parameters** **sequence** > An ATGC string (`str`). \"\"\" return \"\" . join ([ complements [ c ] for c in sequence [ ::- 1 ]]) subset_data_for_overhang def subset_data_for_overhang ( dataframe , overhang , horizontal = True , filter = True ) Subset tatapov dataframe for given overhang. Parameters dataframe Tatapov dataset, for example tatapov.annealing_data[\"25C\"][\"01h\"] overhang Overhang class instance ( Overhang ) horizontal Orientation of returned dataframe ( bool ). filter If True, keep only columns (if horizontal=True) or rows (if horizontal=False) with nonzero values ( bool ). View Source def subset_data_for_overhang ( dataframe , overhang , horizontal = True , filter = True ) : \" \"\" Subset tatapov dataframe for given overhang. **Parameters** **dataframe** > Tatapov dataset, for example `tatapov.annealing_data[\" 25C \"][\" 01h \"]` **overhang** > Overhang class instance (`Overhang`) **horizontal** > Orientation of returned dataframe (`bool`). **filter** > If True, keep only columns (if horizontal=True) or rows (if horizontal=False) with nonzero values (`bool`). \"\" \" overhangs = [ overhang . overhang , overhang . overhang_rc ] if horizontal : subset_data = dataframe . loc [ overhangs ] if filter : subset_data = subset_data . loc [ : , subset_data . sum ( axis = 0 ) != 0 ] return subset_data else : # vertical subset_data = dataframe [ overhangs ] if filter : subset_data = subset_data . loc [ subset_data . sum ( axis = 1 ) != 0 , : ] return subset_data","title":"Tools"},{"location":"reference/overhang/tools/#module-overhangtools","text":"View Source import itertools import tatapov import numpy as np import matplotlib.pyplot as plt complements = { \"A\" : \"T\" , \"T\" : \"A\" , \"C\" : \"G\" , \"G\" : \"C\" } enzyme_tatapov_lookup = { \"BsaI\" : \"2020_01h_BsaI\" , \"BsmBI\" : \"2020_01h_BsmBI\" , \"Esp3I\" : \"2020_01h_Esp3I\" , \"BbsI\" : \"2020_01h_BbsI\" , } def reverse_complement ( sequence ): \"\"\"Return the reverse complement of a DNA sequence. For instance `reverse_complement(\"ATGC\")` returns `\"GCAT\"`. **Parameters** **sequence** > An ATGC string (`str`). \"\"\" return \"\" . join ([ complements [ c ] for c in sequence [:: - 1 ]]) def gc_content ( sequence ): \"\"\"Return the proportion of G and C in the sequence (between 0 and 1). This function is equivalent to `goldenhinges.biotools.gc_content()`. **Parameters** **sequence* > An ATGC string (`str`). \"\"\" return 1.0 * len ([ c for c in sequence if c in \"GC\" ]) / len ( sequence ) def order_overhangs ( seq ): \"\"\"Create an overhang's reverse complement, and return them in order. Overhangs are ordered by the letters, e.g. AATA < TATT. **Parameters** **seq** > ACGT sequence (`str`).\"\"\" sorted_overhangs = [ seq , reverse_complement ( seq )] sorted_overhangs . sort () return sorted_overhangs [ 0 ], sorted_overhangs [ 1 ] def generate_overhang_pairs ( overhang_length = 4 ): \"\"\"Generate all overhang pairs of given length. **Parameters** **overhang_length** > Length of overhangs (`int`). \"\"\" raw_overhangs = [ \"\" . join ( overhang ) for overhang in itertools . product ( * overhang_length * ( \"ACGT\" ,)) ] # adapted from goldenhinges overhang_pairs = [] # for each overhang and its complement for overhang in raw_overhangs : overhang_pairs += [ frozenset ([ overhang , reverse_complement ( overhang )])] overhang_pairs = set ( overhang_pairs ) # remove duplicate pairs return overhang_pairs def subset_data_for_overhang ( dataframe , overhang , horizontal = True , filter = True ): \"\"\"Subset tatapov dataframe for given overhang. **Parameters** **dataframe** > Tatapov dataset, for example `tatapov.annealing_data[\"25C\"][\"01h\"]` **overhang** > Overhang class instance (`Overhang`) **horizontal** > Orientation of returned dataframe (`bool`). **filter** > If True, keep only columns (if horizontal=True) or rows (if horizontal=False) with nonzero values (`bool`). \"\"\" overhangs = [ overhang . overhang , overhang . overhang_rc ] if horizontal : subset_data = dataframe . loc [ overhangs ] if filter : subset_data = subset_data . loc [:, subset_data . sum ( axis = 0 ) != 0 ] return subset_data else : # vertical subset_data = dataframe [ overhangs ] if filter : subset_data = subset_data . loc [ subset_data . sum ( axis = 1 ) != 0 , :] return subset_data def plot_data ( df , ax = None , colorbar = True , figwidth = 8 , plot_color = \"Reds\" ): \"\"\"Plot a (restricted) tatapov dataframe. **Parameters** **df** > One of the data sheets provided by tatapov, e.g. ``annealing_data[\"37C\"][\"01h\"]``. Or a restriction using ``data_subset``. **ax** > A Matplotlib ax. If none is provided, one will be created and returned at the end. **colorbar** > If True, the figure will have a colorbar. **figwidth** > Custom width of the figure. **plot_color** > A Matplotlib colormap name. \"\"\" # Adapted from tatapov.plot_data() if ax is None : _ , ax = plt . subplots ( 1 , figsize = ( figwidth , 1.5 )) values = np . log10 ( np . maximum ( 0.5 , df . values [:: - 1 ])) im = ax . imshow ( values , cmap = plot_color ) if colorbar : ax . figure . colorbar ( im , label = \"log10( occurrences )\" ) xtick_labels = df . columns ax . set_xticks ( range ( len ( xtick_labels ))) ax . set_xticklabels ( xtick_labels , rotation = 90 ) ax . xaxis . tick_top () ax . set_xlim ( right = len ( xtick_labels ) - 0.5 ) ytick_labels = df . index [:: - 1 ] ax . set_yticks ( range ( len ( ytick_labels ))) ax . set_yticklabels ( ytick_labels ) ax . set_ylim ( - 0.5 , len ( ytick_labels ) - 0.5 ) plt . close () return ax , im def filter_overhangs ( overhangs , enzyme = \"Esp3I\" ): \"\"\"Filter overhangs using the Tatapov package. Filter out the weakly annealing and self-misannealing overhangs. **Parameters** **overhangs** > List of Overhang instances (`list`). **enzyme** > Enzyme used with the overhangs (`str`). See `overhang.tools.enzyme_tatapov_lookup` for options. \"\"\" data = tatapov . annealing_data [ \"37C\" ][ enzyme_tatapov_lookup [ enzyme ]] overhang_input = [ overhang . overhang for overhang in overhangs ] subset = tatapov . data_subset ( data , overhang_input , add_reverse = True ) # WEAK ANNEALS # See cutoff 400 in Pryor et al. Figure 2. strong_overhangs = [] for overhang in overhangs : if subset [ overhang . overhang ][ overhang . overhang_rc ] >= 400 : strong_overhangs += [ overhang ] # SELF-MISANNEALS # Use 0 as cutoff: good_overhangs = [] for overhang in strong_overhangs : if ( subset [ overhang . overhang ][ overhang . overhang ] == 0 and subset [ overhang . overhang_rc ][ overhang . overhang_rc ] == 0 ): good_overhangs += [ overhang ] return good_overhangs","title":"Module overhang.tools"},{"location":"reference/overhang/tools/#variables","text":"complements enzyme_tatapov_lookup","title":"Variables"},{"location":"reference/overhang/tools/#functions","text":"","title":"Functions"},{"location":"reference/overhang/tools/#filter_overhangs","text":"def filter_overhangs ( overhangs , enzyme = 'Esp3I' ) Filter overhangs using the Tatapov package. Filter out the weakly annealing and self-misannealing overhangs. Parameters overhangs List of Overhang instances ( list ). enzyme Enzyme used with the overhangs ( str ). See overhang.tools.enzyme_tatapov_lookup for options. View Source def filter_overhangs ( overhangs , enzyme = \"Esp3I\" ): \"\"\"Filter overhangs using the Tatapov package. Filter out the weakly annealing and self-misannealing overhangs. **Parameters** **overhangs** > List of Overhang instances (`list`). **enzyme** > Enzyme used with the overhangs (`str`). See `overhang.tools.enzyme_tatapov_lookup` for options. \"\"\" data = tatapov . annealing_data [ \"37C\" ][ enzyme_tatapov_lookup [ enzyme ]] overhang_input = [ overhang . overhang for overhang in overhangs ] subset = tatapov . data_subset ( data , overhang_input , add_reverse = True ) # WEAK ANNEALS # See cutoff 400 in Pryor et al. Figure 2. strong_overhangs = [] for overhang in overhangs : if subset [ overhang . overhang ][ overhang . overhang_rc ] >= 400 : strong_overhangs += [ overhang ] # SELF-MISANNEALS # Use 0 as cutoff: good_overhangs = [] for overhang in strong_overhangs : if ( subset [ overhang . overhang ][ overhang . overhang ] == 0 and subset [ overhang . overhang_rc ][ overhang . overhang_rc ] == 0 ): good_overhangs += [ overhang ] return good_overhangs","title":"filter_overhangs"},{"location":"reference/overhang/tools/#gc_content","text":"def gc_content ( sequence ) Return the proportion of G and C in the sequence (between 0 and 1). This function is equivalent to goldenhinges.biotools.gc_content() . Parameters * sequence An ATGC string ( str ). View Source def gc_content ( sequence ) : \" \"\" Return the proportion of G and C in the sequence (between 0 and 1). This function is equivalent to `goldenhinges.biotools.gc_content()`. **Parameters** **sequence* > An ATGC string (`str`). \"\" \" return 1.0 * len ( [ c for c in sequence if c in \"GC\" ] ) / len ( sequence )","title":"gc_content"},{"location":"reference/overhang/tools/#generate_overhang_pairs","text":"def generate_overhang_pairs ( overhang_length = 4 ) Generate all overhang pairs of given length. Parameters overhang_length Length of overhangs ( int ). View Source def generate_overhang_pairs ( overhang_length = 4 ) : \" \"\" Generate all overhang pairs of given length. **Parameters** **overhang_length** > Length of overhangs (`int`). \"\" \" raw_overhangs = [ \"\" . join ( overhang ) for overhang in itertools . product ( * overhang_length * ( \"ACGT\" ,)) ] # adapted from goldenhinges overhang_pairs = [] # for each overhang and its complement for overhang in raw_overhangs : overhang_pairs += [ frozenset ( [ overhang , reverse_complement ( overhang ) ] ) ] overhang_pairs = set ( overhang_pairs ) # remove duplicate pairs return overhang_pairs","title":"generate_overhang_pairs"},{"location":"reference/overhang/tools/#order_overhangs","text":"def order_overhangs ( seq ) Create an overhang's reverse complement, and return them in order. Overhangs are ordered by the letters, e.g. AATA < TATT. Parameters seq ACGT sequence ( str ). View Source def order_overhangs ( seq ) : \" \"\" Create an overhang's reverse complement, and return them in order. Overhangs are ordered by the letters, e.g. AATA < TATT. **Parameters** **seq** > ACGT sequence (`str`). \"\" \" sorted_overhangs = [ seq , reverse_complement ( seq ) ] sorted_overhangs . sort () return sorted_overhangs [ 0 ] , sorted_overhangs [ 1 ]","title":"order_overhangs"},{"location":"reference/overhang/tools/#plot_data","text":"def plot_data ( df , ax = None , colorbar = True , figwidth = 8 , plot_color = 'Reds' ) Plot a (restricted) tatapov dataframe. Parameters df One of the data sheets provided by tatapov, e.g. annealing_data[\"37C\"][\"01h\"] . Or a restriction using data_subset . ax A Matplotlib ax. If none is provided, one will be created and returned at the end. colorbar If True, the figure will have a colorbar. figwidth Custom width of the figure. plot_color A Matplotlib colormap name. View Source def plot_data ( df , ax = None , colorbar = True , figwidth = 8 , plot_color= \"Reds\" ) : \"\"\"Plot a (restricted) tatapov dataframe. **Parameters** **df** > One of the data sheets provided by tatapov, e.g. ``annealing_data[\" 37 C \"][\" 01 h \"]``. Or a restriction using ``data_subset``. **ax** > A Matplotlib ax. If none is provided, one will be created and returned at the end. **colorbar** > If True, the figure will have a colorbar. **figwidth** > Custom width of the figure. **plot_color** > A Matplotlib colormap name. \"\"\" # Adapted from tatapov . plot_data () if ax is None : _ , ax = plt . subplots ( 1 , figsize= ( figwidth , 1.5 )) values = np . log10 ( np . maximum ( 0.5 , df . values [ ::- 1 ])) im = ax . imshow ( values , cmap = plot_color ) if colorbar : ax . figure . colorbar ( im , label= \"log10( occurrences )\" ) xtick_labels = df . columns ax . set_xticks ( range ( len ( xtick_labels ))) ax . set_xticklabels ( xtick_labels , rotation = 90 ) ax . xaxis . tick_top () ax . set_xlim ( right = len ( xtick_labels ) - 0.5 ) ytick_labels = df . index [ ::- 1 ] ax . set_yticks ( range ( len ( ytick_labels ))) ax . set_yticklabels ( ytick_labels ) ax . set_ylim ( - 0.5 , len ( ytick_labels ) - 0.5 ) plt . close () return ax , im","title":"plot_data"},{"location":"reference/overhang/tools/#reverse_complement","text":"def reverse_complement ( sequence ) Return the reverse complement of a DNA sequence. For instance reverse_complement(\"ATGC\") returns \"GCAT\" . Parameters sequence An ATGC string ( str ). View Source def reverse_complement ( sequence ) : \"\"\"Return the reverse complement of a DNA sequence. For instance `reverse_complement(\" ATGC \")` returns `\" GCAT \"`. **Parameters** **sequence** > An ATGC string (`str`). \"\"\" return \"\" . join ([ complements [ c ] for c in sequence [ ::- 1 ]])","title":"reverse_complement"},{"location":"reference/overhang/tools/#subset_data_for_overhang","text":"def subset_data_for_overhang ( dataframe , overhang , horizontal = True , filter = True ) Subset tatapov dataframe for given overhang. Parameters dataframe Tatapov dataset, for example tatapov.annealing_data[\"25C\"][\"01h\"] overhang Overhang class instance ( Overhang ) horizontal Orientation of returned dataframe ( bool ). filter If True, keep only columns (if horizontal=True) or rows (if horizontal=False) with nonzero values ( bool ). View Source def subset_data_for_overhang ( dataframe , overhang , horizontal = True , filter = True ) : \" \"\" Subset tatapov dataframe for given overhang. **Parameters** **dataframe** > Tatapov dataset, for example `tatapov.annealing_data[\" 25C \"][\" 01h \"]` **overhang** > Overhang class instance (`Overhang`) **horizontal** > Orientation of returned dataframe (`bool`). **filter** > If True, keep only columns (if horizontal=True) or rows (if horizontal=False) with nonzero values (`bool`). \"\" \" overhangs = [ overhang . overhang , overhang . overhang_rc ] if horizontal : subset_data = dataframe . loc [ overhangs ] if filter : subset_data = subset_data . loc [ : , subset_data . sum ( axis = 0 ) != 0 ] return subset_data else : # vertical subset_data = dataframe [ overhangs ] if filter : subset_data = subset_data . loc [ subset_data . sum ( axis = 1 ) != 0 , : ] return subset_data","title":"subset_data_for_overhang"},{"location":"reference/overhang/version/","text":"Module overhang.version View Source __version__ = \"0.1.2\"","title":"Version"},{"location":"reference/overhang/version/#module-overhangversion","text":"View Source __version__ = \"0.1.2\"","title":"Module overhang.version"}]}